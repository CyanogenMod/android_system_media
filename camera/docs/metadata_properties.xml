<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2012 The Android Open Source Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-->
<metadata xmlns="http://schemas.android.com/service/camera/metadata/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://schemas.android.com/service/camera/metadata/ metadata_properties.xsd">

  <tags>
    <tag id="AWB">
        Needed for auto white balance
    </tag>
    <tag id="BC">
        Needed for backwards compatibility with old Java API
    </tag>
    <tag id="V1">
        New features for first camera 2 release (API1)
    </tag>
    <tag id="ADV">
      <!-- TODO: fill the tag description -->
    </tag>
    <tag id="DNG">
        Needed for DNG file support
    </tag>
    <tag id="EXIF">
      <!-- TODO: fill the tag description -->
    </tag>
    <tag id="HAL2">
        Entry is only used by camera device HAL 2.x
    </tag>
    <tag id="FULL">
        Entry is required for full hardware level devices, and optional for other hardware levels
    </tag>
    <tag id="LIMITED">
      Entry assists with LIMITED device implementation. LIMITED devices
      must implement all entries with this tag. Optional for FULL devices.
    </tag>
  </tags>

  <types>
    <typedef name="rectangle">
      <language name="java">android.graphics.Rect</language>
    </typedef>
    <typedef name="size">
      <language name="java">android.hardware.camera2.Size</language>
    </typedef>
    <typedef name="string">
      <language name="java">String</language>
    </typedef>
    <typedef name="boolean">
      <language name="java">boolean</language>
    </typedef>
    <typedef name="imageFormat">
      <language name="java">int</language>
    </typedef>
  </types>

  <namespace name="android">
    <section name="colorCorrection">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>TRANSFORM_MATRIX
              <notes>Use the android.colorCorrection.transform matrix
                and android.colorCorrection.gains to do color conversion.

                All advanced white balance adjustments (not specified
                by our white balance pipeline) must be disabled.

                If AWB is enabled with `android.control.awbMode != OFF`, then
                TRANSFORM_MATRIX is ignored. The camera device will override
                this value to either FAST or HIGH_QUALITY.
              </notes>
            </value>
            <value>FAST
              <notes>Must not slow down capture rate relative to sensor raw
              output.

              Advanced white balance adjustments above and beyond
              the specified white balance pipeline may be applied.

              If AWB is enabled with `android.control.awbMode != OFF`, then
              the camera device uses the last frame's AWB values
              (or defaults if AWB has never been run).
            </notes>
            </value>
            <value>HIGH_QUALITY
              <notes>Capture rate (relative to sensor raw output)
              may be reduced by high quality.

              Advanced white balance adjustments above and beyond
              the specified white balance pipeline may be applied.

              If AWB is enabled with `android.control.awbMode != OFF`, then
              the camera device uses the last frame's AWB values
              (or defaults if AWB has never been run).
            </notes>
            </value>
          </enum>

          <description>
          The mode control selects how the image data is converted from the
          sensor's native color into linear sRGB color.
          </description>
          <details>
          When auto-white balance is enabled with android.control.awbMode, this
          control is overridden by the AWB routine. When AWB is disabled, the
          application controls how the color mapping is performed.

          We define the expected processing pipeline below. For consistency
          across devices, this is always the case with TRANSFORM_MATRIX.

          When either FULL or HIGH_QUALITY is used, the camera device may
          do additional processing but android.colorCorrection.gains and
          android.colorCorrection.transform will still be provided by the
          camera device (in the results) and be roughly correct.

          Switching to TRANSFORM_MATRIX and using the data provided from
          FAST or HIGH_QUALITY will yield a picture with the same white point
          as what was produced by the camera device in the earlier frame.

          The expected processing pipeline is as follows:

          ![White balance processing pipeline](android.colorCorrection.mode/processing_pipeline.png)

          The white balance is encoded by two values, a 4-channel white-balance
          gain vector (applied in the Bayer domain), and a 3x3 color transform
          matrix (applied after demosaic).

          The 4-channel white-balance gains are defined as:

              android.colorCorrection.gains = [ R G_even G_odd B ]

          where `G_even` is the gain for green pixels on even rows of the
          output, and `G_odd` is the gain for green pixels on the odd rows.
          These may be identical for a given camera device implementation; if
          the camera device does not support a separate gain for even/odd green
          channels, it will use the `G_even` value, and write `G_odd` equal to
          `G_even` in the output result metadata.

          The matrices for color transforms are defined as a 9-entry vector:

              android.colorCorrection.transform = [ I0 I1 I2 I3 I4 I5 I6 I7 I8 ]

          which define a transform from input sensor colors, `P_in = [ r g b ]`,
          to output linear sRGB, `P_out = [ r' g' b' ]`,

          with colors as follows:

              r' = I0r + I1g + I2b
              g' = I3r + I4g + I5b
              b' = I6r + I7g + I8b

          Both the input and output value ranges must match. Overflow/underflow
          values are clipped to fit within the range.
          </details>
        </entry>
        <entry name="transform" type="rational" visibility="public"
               type_notes="3x3 rational matrix in row-major order"
               container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>A color transform matrix to use to transform
          from sensor RGB color space to output linear sRGB color space
          </description>
          <details>This matrix is either set by the camera device when the request
          android.colorCorrection.mode is not TRANSFORM_MATRIX, or
          directly by the application in the request when the
          android.colorCorrection.mode is TRANSFORM_MATRIX.

          In the latter case, the camera device may round the matrix to account
          for precision issues; the final rounded matrix should be reported back
          in this matrix result metadata. The transform should keep the magnitude
          of the output color values within `[0, 1.0]` (assuming input color
          values is within the normalized range `[0, 1.0]`), or clipping may occur.
          </details>
        </entry>
        <entry name="gains" type="float" visibility="public"
               type_notes="A 1D array of floats for 4 color channel gains"
               container="array">
          <array>
            <size>4</size>
          </array>
          <description>Gains applying to Bayer raw color channels for
          white-balance.</description>
          <details>The 4-channel white-balance gains are defined in
          the order of `[R G_even G_odd B]`, where `G_even` is the gain
          for green pixels on even rows of the output, and `G_odd`
          is the gain for green pixels on the odd rows. if a HAL
          does not support a separate gain for even/odd green channels,
          it should use the `G_even` value, and write `G_odd` equal to
          `G_even` in the output result metadata.

          This array is either set by the camera device when the request
          android.colorCorrection.mode is not TRANSFORM_MATRIX, or
          directly by the application in the request when the
          android.colorCorrection.mode is TRANSFORM_MATRIX.

          The output should be the gains actually applied by the camera device to
          the current frame.</details>
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.colorCorrection.mode" kind="controls">
        </clone>
        <clone entry="android.colorCorrection.transform" kind="controls">
        </clone>
        <clone entry="android.colorCorrection.gains" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="control">
      <controls>
        <entry name="aeAntibandingMode" type="byte" visibility="public"
               enum="true" >
          <enum>
            <value>OFF
              <notes>
                The camera device will not adjust exposure duration to
                avoid banding problems.
              </notes>
            </value>
            <value>50HZ
              <notes>
                The camera device will adjust exposure duration to
                avoid banding problems with 50Hz illumination sources.
              </notes>
            </value>
            <value>60HZ
              <notes>
                The camera device will adjust exposure duration to
                avoid banding problems with 60Hz illumination
                sources.
              </notes>
            </value>
            <value>AUTO
              <notes>
                The camera device will automatically adapt its
                antibanding routine to the current illumination
                conditions. This is the default.
              </notes>
            </value>
          </enum>
          <description>
            The desired setting for the camera device's auto-exposure
            algorithm's antibanding compensation.
          </description>
          <range>
            android.control.aeAvailableAntibandingModes
          </range>
          <details>
            Some kinds of lighting fixtures, such as some fluorescent
            lights, flicker at the rate of the power supply frequency
            (60Hz or 50Hz, depending on country). While this is
            typically not noticeable to a person, it can be visible to
            a camera device. If a camera sets its exposure time to the
            wrong value, the flicker may become visible in the
            viewfinder as flicker or in a final captured image, as a
            set of variable-brightness bands across the image.

            Therefore, the auto-exposure routines of camera devices
            include antibanding routines that ensure that the chosen
            exposure value will not cause such banding. The choice of
            exposure time depends on the rate of flicker, which the
            camera device can detect automatically, or the expected
            rate can be selected by the application using this
            control.

            A given camera device may not support all of the possible
            options for the antibanding mode. The
            android.control.aeAvailableAntibandingModes key contains
            the available modes for a given camera device.

            The default mode is AUTO, which must be supported by all
            camera devices.

            If manual exposure control is enabled (by setting
            android.control.aeMode or android.control.mode to OFF),
            then this setting has no effect, and the application must
            ensure it selects exposure times that do not cause banding
            issues. The android.statistics.sceneFlicker key can assist
            the application in this.
          </details>
          <hal_details>
            For all capture request templates, this field must be set
            to AUTO.  AUTO is the only mode that must supported;
            OFF, 50HZ, 60HZ are all optional.

            If manual exposure control is enabled (by setting
            android.control.aeMode or android.control.mode to OFF),
            then the exposure values provided by the application must not be
            adjusted for antibanding.
          </hal_details>
          <tag id="BC" />
        </entry>
        <entry name="aeExposureCompensation" type="int32" visibility="public">
          <description>Adjustment to AE target image
          brightness</description>
          <units>count of positive/negative EV steps</units>
          <details>For example, if EV step is 0.333, '6' will mean an
          exposure compensation of +2 EV; -3 will mean an exposure
          compensation of -1</details>
          <tag id="BC" />
        </entry>
        <entry name="aeLock" type="byte" visibility="public" enum="true"
               typedef="boolean">
          <enum>
            <value>OFF
            <notes>Autoexposure lock is disabled; the AE algorithm
            is free to update its parameters.</notes></value>
            <value>ON
            <notes>Autoexposure lock is enabled; the AE algorithm
            must not update the exposure and sensitivity parameters
            while the lock is active</notes></value>
          </enum>
          <description>Whether AE is currently locked to its latest
          calculated values.</description>
          <details>Note that even when AE is locked, the flash may be
          fired if the android.control.aeMode is ON_AUTO_FLASH / ON_ALWAYS_FLASH /
          ON_AUTO_FLASH_REDEYE.

          If AE precapture is triggered (see android.control.aePrecaptureTrigger)
          when AE is already locked, the camera device will not change the exposure time
          (android.sensor.exposureTime) and sensitivity (android.sensor.sensitivity)
          parameters. The flash may be fired if the android.control.aeMode
          is ON_AUTO_FLASH/ON_AUTO_FLASH_REDEYE and the scene is too dark. If the
          android.control.aeMode is ON_ALWAYS_FLASH, the scene may become overexposed.

          See android.control.aeState for AE lock related state transition details.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="aeMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
                The camera device's autoexposure routine is disabled;
                the application-selected android.sensor.exposureTime,
                android.sensor.sensitivity and
                android.sensor.frameDuration are used by the camera
                device, along with android.flash.* fields, if there's
                a flash unit for this camera device.
              </notes>
            </value>
            <value>ON
              <notes>
                The camera device's autoexposure routine is active,
                with no flash control. The application's values for
                android.sensor.exposureTime,
                android.sensor.sensitivity, and
                android.sensor.frameDuration are ignored. The
                application has control over the various
                android.flash.* fields.
              </notes>
            </value>
            <value>ON_AUTO_FLASH
              <notes>
                Like ON, except that the camera device also controls
                the camera's flash unit, firing it in low-light
                conditions. The flash may be fired during a
                precapture sequence (triggered by
                android.control.aePrecaptureTrigger) and may be fired
                for captures for which the
                android.control.captureIntent field is set to
                STILL_CAPTURE
              </notes>
            </value>
            <value>ON_ALWAYS_FLASH
              <notes>
                Like ON, except that the camera device also controls
                the camera's flash unit, always firing it for still
                captures. The flash may be fired during a precapture
                sequence (triggered by
                android.control.aePrecaptureTrigger) and will always
                be fired for captures for which the
                android.control.captureIntent field is set to
                STILL_CAPTURE
              </notes>
            </value>
            <value>ON_AUTO_FLASH_REDEYE
              <notes>
                Like ON_AUTO_FLASH, but with automatic red eye
                reduction. If deemed necessary by the camera device,
                a red eye reduction flash will fire during the
                precapture sequence.
              </notes>
            </value>
          </enum>
          <description>The desired mode for the camera device's
          auto-exposure routine.</description>
          <range>android.control.aeAvailableModes</range>
          <details>
            This control is only effective if android.control.mode is
            AUTO.

            When set to any of the ON modes, the camera device's
            auto-exposure routine is enabled, overriding the
            application's selected exposure time, sensor sensitivity,
            and frame duration (android.sensor.exposureTime,
            android.sensor.sensitivity, and
            android.sensor.frameDuration). If one of the FLASH modes
            is selected, the camera device's flash unit controls are
            also overridden.

            The FLASH modes are only available if the camera device
            has a flash unit (android.flash.info.available is `true`).

            If flash TORCH mode is desired, this field must be set to
            ON or OFF, and android.flash.mode set to TORCH.

            When set to any of the ON modes, the values chosen by the
            camera device auto-exposure routine for the overridden
            fields for a given capture will be available in its
            CaptureResult.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="aeRegions" type="int32" visibility="public"
               container="array">
          <array>
            <size>5</size>
            <size>area_count</size>
          </array>
          <description>List of areas to use for
          metering.</description>
          <range>`area_count &lt;= android.control.maxRegions[0]`</range>
          <details>Each area is a rectangle plus weight: xmin, ymin,
          xmax, ymax, weight. The rectangle is defined to be inclusive of the
          specified coordinates.

          The coordinate system is based on the active pixel array,
          with (0,0) being the top-left pixel in the active pixel array, and
          (android.sensor.info.activeArraySize.width - 1,
          android.sensor.info.activeArraySize.height - 1) being the
          bottom-right pixel in the active pixel array. The weight
          should be nonnegative.

          If all regions have 0 weight, then no specific metering area
          needs to be used by the camera device. If the metering region is
          outside the current android.scaler.cropRegion, the camera device
          will ignore the sections outside the region and output the
          used sections in the frame metadata.</details>
          <tag id="BC" />
        </entry>
        <entry name="aeTargetFpsRange" type="int32" visibility="public"
               container="array">
          <array>
            <size>2</size>
          </array>
          <description>Range over which fps can be adjusted to
          maintain exposure</description>
          <range>android.control.aeAvailableTargetFpsRanges</range>
          <details>Only constrains AE algorithm, not manual control
          of android.sensor.exposureTime</details>
          <tag id="BC" />
        </entry>
        <entry name="aePrecaptureTrigger" type="byte" visibility="public"
               enum="true">
          <enum>
            <value>IDLE
              <notes>The trigger is idle.</notes>
            </value>
            <value>START
              <notes>The precapture metering sequence will be started
              by the camera device. The exact effect of the precapture
              trigger depends on the current AE mode and state.</notes>
            </value>
          </enum>
          <description>Whether the camera device will trigger a precapture
          metering sequence when it processes this request.</description>
          <details>This entry is normally set to IDLE, or is not
          included at all in the request settings. When included and
          set to START, the camera device will trigger the autoexposure
          precapture metering sequence.

          The effect of AE precapture trigger depends on the current
          AE mode and state; see android.control.aeState for AE precapture
          state transition details.</details>
          <tag id="BC" />
        </entry>
        <entry name="afMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>The auto-focus routine does not control the lens;
            android.lens.focusDistance is controlled by the
            application</notes></value>
            <value>AUTO
            <notes>
            If lens is not fixed focus.

            Use android.lens.info.minimumFocusDistance to determine if lens
            is fixed-focus. In this mode, the lens does not move unless
            the autofocus trigger action is called. When that trigger
            is activated, AF must transition to ACTIVE_SCAN, then to
            the outcome of the scan (FOCUSED or NOT_FOCUSED).

            Triggering AF_CANCEL resets the lens position to default,
            and sets the AF state to INACTIVE.</notes></value>
            <value>MACRO
            <notes>In this mode, the lens does not move unless the
            autofocus trigger action is called.

            When that trigger is activated, AF must transition to
            ACTIVE_SCAN, then to the outcome of the scan (FOCUSED or
            NOT_FOCUSED).  Triggering cancel AF resets the lens
            position to default, and sets the AF state to
            INACTIVE.</notes></value>
            <value>CONTINUOUS_VIDEO
            <notes>In this mode, the AF algorithm modifies the lens
            position continually to attempt to provide a
            constantly-in-focus image stream.

            The focusing behavior should be suitable for good quality
            video recording; typically this means slower focus
            movement and no overshoots. When the AF trigger is not
            involved, the AF algorithm should start in INACTIVE state,
            and then transition into PASSIVE_SCAN and PASSIVE_FOCUSED
            states as appropriate. When the AF trigger is activated,
            the algorithm should immediately transition into
            AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the
            lens position until a cancel AF trigger is received.

            Once cancel is received, the algorithm should transition
            back to INACTIVE and resume passive scan. Note that this
            behavior is not identical to CONTINUOUS_PICTURE, since an
            ongoing PASSIVE_SCAN must immediately be
            canceled.</notes></value>
            <value>CONTINUOUS_PICTURE
            <notes>In this mode, the AF algorithm modifies the lens
            position continually to attempt to provide a
            constantly-in-focus image stream.

            The focusing behavior should be suitable for still image
            capture; typically this means focusing as fast as
            possible. When the AF trigger is not involved, the AF
            algorithm should start in INACTIVE state, and then
            transition into PASSIVE_SCAN and PASSIVE_FOCUSED states as
            appropriate as it attempts to maintain focus. When the AF
            trigger is activated, the algorithm should finish its
            PASSIVE_SCAN if active, and then transition into
            AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the
            lens position until a cancel AF trigger is received.

            When the AF cancel trigger is activated, the algorithm
            should transition back to INACTIVE and then act as if it
            has just been started.</notes></value>
            <value>EDOF
            <notes>Extended depth of field (digital focus). AF
            trigger is ignored, AF state should always be
            INACTIVE.</notes></value>
          </enum>
          <description>Whether AF is currently enabled, and what
          mode it is set to</description>
          <range>android.control.afAvailableModes</range>
          <details>Only effective if android.control.mode = AUTO and the lens is not fixed focus
          (i.e. `android.lens.info.minimumFocusDistance &gt; 0`).

          If the lens is controlled by the camera device auto-focus algorithm,
          the camera device will report the current AF status in android.control.afState
          in result metadata.</details>
          <tag id="BC" />
        </entry>
        <entry name="afRegions" type="int32" visibility="public"
               container="array">
          <array>
            <size>5</size>
            <size>area_count</size>
          </array>
          <description>List of areas to use for focus
          estimation.</description>
          <range>`area_count &lt;= android.control.maxRegions[2]`</range>
          <details>Each area is a rectangle plus weight: xmin, ymin,
          xmax, ymax, weight. The rectangle is defined to be inclusive of the
          specified coordinates.

          The coordinate system is based on the active pixel array,
          with (0,0) being the top-left pixel in the active pixel array, and
          (android.sensor.info.activeArraySize.width - 1,
          android.sensor.info.activeArraySize.height - 1) being the
          bottom-right pixel in the active pixel array. The weight
          should be nonnegative.

          If all regions have 0 weight, then no specific focus area
          needs to be used by the camera device. If the focusing region is
          outside the current android.scaler.cropRegion, the camera device
          will ignore the sections outside the region and output the
          used sections in the frame metadata.</details>
          <tag id="BC" />
        </entry>
        <entry name="afTrigger" type="byte" visibility="public" enum="true">
          <enum>
            <value>IDLE
              <notes>The trigger is idle.</notes>
            </value>
            <value>START
              <notes>Autofocus will trigger now.</notes>
            </value>
            <value>CANCEL
              <notes>Autofocus will return to its initial
              state, and cancel any currently active trigger.</notes>
            </value>
          </enum>
          <description>
          Whether the camera device will trigger autofocus for this request.
          </description>
          <details>This entry is normally set to IDLE, or is not
          included at all in the request settings.

          When included and set to START, the camera device will trigger the
          autofocus algorithm. If autofocus is disabled, this trigger has no effect.

          When set to CANCEL, the camera device will cancel any active trigger,
          and return to its initial AF state.

          See android.control.afState for what that means for each AF mode.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="awbLock" type="byte" visibility="public" enum="true"
               typedef="boolean">
          <enum>
            <value>OFF
            <notes>Auto-whitebalance lock is disabled; the AWB
            algorithm is free to update its parameters if in AUTO
            mode.</notes></value>
            <value>ON
            <notes>Auto-whitebalance lock is enabled; the AWB
            algorithm must not update its parameters while the lock
            is active.</notes></value>
          </enum>
          <description>Whether AWB is currently locked to its
          latest calculated values.</description>
          <details>Note that AWB lock is only meaningful for AUTO
          mode; in other modes, AWB is already fixed to a specific
          setting.</details>
          <tag id="BC" />
        </entry>
        <entry name="awbMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>
            The camera device's auto white balance routine is disabled;
            the application-selected color transform matrix
            (android.colorCorrection.transform) and gains
            (android.colorCorrection.gains) are used by the camera
            device for manual white balance control.
            </notes>
            </value>
            <value>AUTO
            <notes>
            The camera device's auto white balance routine is active;
            the application's values for android.colorCorrection.transform
            and android.colorCorrection.gains are ignored.
            </notes>
            </value>
            <value>INCANDESCENT
            <notes>
            The camera device's auto white balance routine is disabled;
            the camera device uses incandescent light as the assumed scene
            illumination for white balance. While the exact white balance
            transforms are up to the camera device, they will approximately
            match the CIE standard illuminant A.
            </notes>
            </value>
            <value>FLUORESCENT
            <notes>
            The camera device's auto white balance routine is disabled;
            the camera device uses fluorescent light as the assumed scene
            illumination for white balance. While the exact white balance
            transforms are up to the camera device, they will approximately
            match the CIE standard illuminant F2.
            </notes>
            </value>
            <value>WARM_FLUORESCENT
            <notes>
            The camera device's auto white balance routine is disabled;
            the camera device uses warm fluorescent light as the assumed scene
            illumination for white balance. While the exact white balance
            transforms are up to the camera device, they will approximately
            match the CIE standard illuminant F4.
            </notes>
            </value>
            <value>DAYLIGHT
            <notes>
            The camera device's auto white balance routine is disabled;
            the camera device uses daylight light as the assumed scene
            illumination for white balance. While the exact white balance
            transforms are up to the camera device, they will approximately
            match the CIE standard illuminant D65.
            </notes>
            </value>
            <value>CLOUDY_DAYLIGHT
            <notes>
            The camera device's auto white balance routine is disabled;
            the camera device uses cloudy daylight light as the assumed scene
            illumination for white balance.
            </notes>
            </value>
            <value>TWILIGHT
            <notes>
            The camera device's auto white balance routine is disabled;
            the camera device uses twilight light as the assumed scene
            illumination for white balance.
            </notes>
            </value>
            <value>SHADE
            <notes>
            The camera device's auto white balance routine is disabled;
            the camera device uses shade light as the assumed scene
            illumination for white balance.
            </notes>
            </value>
          </enum>
          <description>Whether AWB is currently setting the color
          transform fields, and what its illumination target
          is.</description>
          <range>android.control.awbAvailableModes</range>
          <details>
          This control is only effective if android.control.mode is AUTO.

          When set to the ON mode, the camera device's auto white balance
          routine is enabled, overriding the application's selected
          android.colorCorrection.transform, android.colorCorrection.gains and
          android.colorCorrection.mode.

          When set to the OFF mode, the camera device's auto white balance
          routine is disabled. The application manually controls the white
          balance by android.colorCorrection.transform, android.colorCorrection.gains
          and android.colorCorrection.mode.

          When set to any other modes, the camera device's auto white balance
          routine is disabled. The camera device uses each particular illumination
          target for white balance adjustment.
          </details>
          <tag id="BC" />
          <tag id="AWB" />
        </entry>
        <entry name="awbRegions" type="int32" visibility="public"
               container="array">
          <array>
            <size>5</size>
            <size>area_count</size>
          </array>
          <description>List of areas to use for illuminant
          estimation.</description>
          <range>`area_count &lt;= android.control.maxRegions[1]`</range>
          <details>Only used in AUTO mode.

          Each area is a rectangle plus weight: xmin, ymin,
          xmax, ymax, weight. The rectangle is defined to be inclusive of the
          specified coordinates.

          The coordinate system is based on the active pixel array,
          with (0,0) being the top-left pixel in the active pixel array, and
          (android.sensor.info.activeArraySize.width - 1,
          android.sensor.info.activeArraySize.height - 1) being the
          bottom-right pixel in the active pixel array. The weight
          should be nonnegative.

          If all regions have 0 weight, then no specific auto-white balance (AWB) area
          needs to be used by the camera device. If the AWB region is
          outside the current android.scaler.cropRegion, the camera device
          will ignore the sections outside the region and output the
          used sections in the frame metadata.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="captureIntent" type="byte" visibility="public" enum="true">
          <enum>
            <value>CUSTOM
            <notes>This request doesn't fall into the other
            categories. Default to preview-like
            behavior.</notes></value>
            <value>PREVIEW
            <notes>This request is for a preview-like usecase. The
            precapture trigger may be used to start off a metering
            w/flash sequence</notes></value>
            <value>STILL_CAPTURE
            <notes>This request is for a still capture-type
            usecase.</notes></value>
            <value>VIDEO_RECORD
            <notes>This request is for a video recording
            usecase.</notes></value>
            <value>VIDEO_SNAPSHOT
            <notes>This request is for a video snapshot (still
            image while recording video) usecase</notes></value>
            <value>ZERO_SHUTTER_LAG
            <notes>This request is for a ZSL usecase; the
            application will stream full-resolution images and
            reprocess one or several later for a final
            capture</notes></value>
            <value>MANUAL
            <notes>This request is for manual capture use case where
            the applications want to directly control the capture parameters
            (e.g. android.sensor.exposureTime, android.sensor.sensitivity etc.).
            </notes></value>
          </enum>
          <description>Information to the camera device 3A (auto-exposure,
          auto-focus, auto-white balance) routines about the purpose
          of this capture, to help the camera device to decide optimal 3A
          strategy.</description>
          <range>All must be supported except for ZERO_SHUTTER_LAG and MANUAL.</range>
          <details>This control (except for MANUAL) is only effective if
          `android.control.mode != OFF` and any 3A routine is active.

          ZERO_SHUTTER_LAG must be supported if android.request.availableCapabilities
          contains ZSL. MANUAL must be supported if android.request.availableCapabilities
          contains MANUAL_SENSOR.</details>
          <tag id="BC" />
        </entry>
        <entry name="effectMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
              No color effect will be applied.
              </notes>
            </value>
            <value optional="true">MONO
              <notes>
              A "monocolor" effect where the image is mapped into
              a single color.  This will typically be grayscale.
              </notes>
            </value>
            <value optional="true">NEGATIVE
              <notes>
              A "photo-negative" effect where the image's colors
              are inverted.
              </notes>
            </value>
            <value optional="true">SOLARIZE
              <notes>
              A "solarisation" effect (Sabattier effect) where the
              image is wholly or partially reversed in
              tone.
              </notes>
            </value>
            <value optional="true">SEPIA
              <notes>
              A "sepia" effect where the image is mapped into warm
              gray, red, and brown tones.
              </notes>
            </value>
            <value optional="true">POSTERIZE
              <notes>
              A "posterization" effect where the image uses
              discrete regions of tone rather than a continuous
              gradient of tones.
              </notes>
            </value>
            <value optional="true">WHITEBOARD
              <notes>
              A "whiteboard" effect where the image is typically displayed
              as regions of white, with black or grey details.
              </notes>
            </value>
            <value optional="true">BLACKBOARD
              <notes>
              A "blackboard" effect where the image is typically displayed
              as regions of black, with white or grey details.
              </notes>
            </value>
            <value optional="true">AQUA
              <notes>
              An "aqua" effect where a blue hue is added to the image.
              </notes>
            </value>
          </enum>
          <description>A special color effect to apply.</description>
          <range>android.control.availableEffects</range>
          <details>
          When this mode is set, a color effect will be applied
          to images produced by the camera device. The interpretation
          and implementation of these color effects is left to the
          implementor of the camera device, and should not be
          depended on to be consistent (or present) across all
          devices.

          A color effect will only be applied if
          android.control.mode != OFF.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>Full application control of pipeline. All 3A
            routines are disabled, no other settings in
            android.control.* have any effect</notes></value>
            <value>AUTO
            <notes>Use settings for each individual 3A routine.
            Manual control of capture parameters is disabled. All
            controls in android.control.* besides sceneMode take
            effect</notes></value>
            <value>USE_SCENE_MODE
            <notes>Use specific scene mode. Enabling this disables
            control.aeMode, control.awbMode and control.afMode
            controls; the camera device will ignore those settings while
            USE_SCENE_MODE is active (except for FACE_PRIORITY
            scene mode). Other control entries are still active.
            This setting can only be used if scene mode is supported
            (i.e. android.control.availableSceneModes contain some modes
            other than DISABLED).
            </notes></value>
            <value>OFF_KEEP_STATE
            <notes>Same as OFF mode, except that this capture will not be
            used by camera device background auto-exposure, auto-white balance and
            auto-focus algorithms to update their statistics.</notes></value>
          </enum>
          <description>Overall mode of 3A control
          routines.</description>
          <range>all must be supported</range>
          <details>High-level 3A control. When set to OFF, all 3A control
          by the camera device is disabled. The application must set the fields for
          capture parameters itself.

          When set to AUTO, the individual algorithm controls in
          android.control.* are in effect, such as android.control.afMode.

          When set to USE_SCENE_MODE, the individual controls in
          android.control.* are mostly disabled, and the camera device implements
          one of the scene mode settings (such as ACTION, SUNSET, or PARTY)
          as it wishes. The camera device scene mode 3A settings are provided by
          android.control.sceneModeOverrides.

          When set to OFF_KEEP_STATE, it is similar to OFF mode, the only difference
          is that this frame will not be used by camera device background 3A statistics
          update, as if this frame is never captured. This mode can be used in the scenario
          where the application doesn't want a 3A manual control capture to affect
          the subsequent auto 3A capture results.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="sceneMode" type="byte" visibility="public" enum="true">
          <enum>
            <value id="0">DISABLED
              <notes>
              Indicates that no scene modes are set for a given capture request.
              </notes>
            </value>
            <value>FACE_PRIORITY
              <notes>If face detection support exists, use face
              detection data for auto-focus, auto-white balance, and
              auto-exposure routines. If face detection statistics are
              disabled (i.e. android.statistics.faceDetectMode is set to OFF),
              this should still operate correctly (but will not return
              face detection statistics to the framework).

              Unlike the other scene modes, android.control.aeMode,
              android.control.awbMode, and android.control.afMode
              remain active when FACE_PRIORITY is set.
              </notes>
            </value>
            <value optional="true">ACTION
              <notes>
              Optimized for photos of quickly moving objects.
              Similar to SPORTS.
              </notes>
            </value>
            <value optional="true">PORTRAIT
              <notes>
              Optimized for still photos of people.
              </notes>
            </value>
            <value optional="true">LANDSCAPE
              <notes>
              Optimized for photos of distant macroscopic objects.
              </notes>
            </value>
            <value optional="true">NIGHT
              <notes>
              Optimized for low-light settings.
              </notes>
            </value>
            <value optional="true">NIGHT_PORTRAIT
              <notes>
              Optimized for still photos of people in low-light
              settings.
              </notes>
            </value>
            <value optional="true">THEATRE
              <notes>
              Optimized for dim, indoor settings where flash must
              remain off.
              </notes>
            </value>
            <value optional="true">BEACH
              <notes>
              Optimized for bright, outdoor beach settings.
              </notes>
            </value>
            <value optional="true">SNOW
              <notes>
              Optimized for bright, outdoor settings containing snow.
              </notes>
            </value>
            <value optional="true">SUNSET
              <notes>
              Optimized for scenes of the setting sun.
              </notes>
            </value>
            <value optional="true">STEADYPHOTO
              <notes>
              Optimized to avoid blurry photos due to small amounts of
              device motion (for example: due to hand shake).
              </notes>
            </value>
            <value optional="true">FIREWORKS
              <notes>
              Optimized for nighttime photos of fireworks.
              </notes>
            </value>
            <value optional="true">SPORTS
              <notes>
              Optimized for photos of quickly moving people.
              Similar to ACTION.
              </notes>
            </value>
            <value optional="true">PARTY
              <notes>
              Optimized for dim, indoor settings with multiple moving
              people.
              </notes>
            </value>
            <value optional="true">CANDLELIGHT
              <notes>
              Optimized for dim settings where the main light source
              is a flame.
              </notes>
            </value>
            <value optional="true">BARCODE
              <notes>
              Optimized for accurately capturing a photo of barcode
              for use by camera applications that wish to read the
              barcode value.
              </notes>
            </value>
          </enum>
          <description>
          A camera mode optimized for conditions typical in a particular
          capture setting.
          </description>
          <range>android.control.availableSceneModes</range>
          <details>
          This is the mode that that is active when
          `android.control.mode == USE_SCENE_MODE`. Aside from FACE_PRIORITY,
          these modes will disable android.control.aeMode,
          android.control.awbMode, and android.control.afMode while in use.

          The interpretation and implementation of these scene modes is left
          to the implementor of the camera device. Their behavior will not be
          consistent across all devices, and any given device may only implement
          a subset of these modes.
          </details>
          <hal_details>
          HAL implementations that include scene modes are expected to provide
          the per-scene settings to use for android.control.aeMode,
          android.control.awbMode, and android.control.afMode in
          android.control.sceneModeOverrides.
          </hal_details>
          <tag id="BC" />
        </entry>
        <entry name="videoStabilizationMode" type="byte" visibility="public"
               enum="true">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>Whether video stabilization is
          active</description>
          <details>If enabled, video stabilization can modify the
          android.scaler.cropRegion to keep the video stream
          stabilized</details>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <entry name="aeAvailableAntibandingModes" type="byte" visibility="public"
               type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>
            The set of auto-exposure antibanding modes that are
            supported by this camera device.
          </description>
          <details>
            Not all of the auto-exposure anti-banding modes may be
            supported by a given camera device. This field lists the
            valid anti-banding modes that the application may request
            for this camera device; they must include AUTO.
          </details>
        </entry>
        <entry name="aeAvailableModes" type="byte" visibility="public"
               type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>
            The set of auto-exposure modes that are supported by this
            camera device.
          </description>
          <details>
            Not all the auto-exposure modes may be supported by a
            given camera device, especially if no flash unit is
            available. This entry lists the valid modes for
            android.control.aeMode for this camera device.

            All camera devices support ON, and all camera devices with
            flash units support ON_AUTO_FLASH and
            ON_ALWAYS_FLASH.

            FULL mode camera devices always support OFF mode,
            which enables application control of camera exposure time,
            sensitivity, and frame duration.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="aeAvailableTargetFpsRanges" type="int32" visibility="public"
               type_notes="list of pairs of frame rates"
               container="array">
          <array>
            <size>2</size>
            <size>n</size>
          </array>
          <description>List of frame rate ranges supported by the
          AE algorithm/hardware</description>
        </entry>
        <entry name="aeCompensationRange" type="int32" visibility="public"
               container="array">
          <array>
            <size>2</size>
          </array>
          <description>Maximum and minimum exposure compensation
          setting, in counts of
          android.control.aeCompensationStep.</description>
          <range>At least (-2,2)/(exp compensation step
          size)</range>
          <tag id="BC" />
        </entry>
        <entry name="aeCompensationStep" type="rational" visibility="public">
          <description>Smallest step by which exposure compensation
          can be changed</description>
          <range>&lt;= 1/2</range>
          <tag id="BC" />
        </entry>
        <entry name="afAvailableModes" type="byte" visibility="public"
        type_notes="List of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>List of AF modes that can be
          selected with android.control.afMode.</description>
          <details>
          Not all the auto-focus modes may be supported by a
          given camera device. This entry lists the valid modes for
          android.control.afMode for this camera device.

          All camera devices will support OFF mode, and all camera devices with
          adjustable focuser units (`android.lens.info.minimumFocusDistance &gt; 0`)
          will support AUTO mode.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="availableEffects" type="byte" visibility="public"
               type_notes="List of enums (android.control.effectMode)." container="array">
          <array>
            <size>n</size>
          </array>
          <description>
          List containing the subset of color effects
          specified in android.control.effectMode that is supported by
          this device.
          </description>
          <range>
          Any subset of enums from those specified in
          android.control.effectMode.  OFF must be included in any subset.
          </range>
          <details>
          This list contains the color effect modes that can be applied to
          images produced by the camera device. Only modes that have
          been fully implemented for the current device may be included here.
          Implementations are not expected to be consistent across all devices.
          If no color effect modes are available for a device, this should
          simply be set to OFF.

          A color effect will only be applied if
          android.control.mode != OFF.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="availableSceneModes" type="byte" visibility="public"
               type_notes="List of enums (android.control.sceneMode)."
               container="array">
          <array>
            <size>n</size>
          </array>
          <description>
          List containing a subset of scene modes
          specified in android.control.sceneMode.
          </description>
          <range>
          Any subset of the enums specified in android.control.sceneMode
          not including DISABLED, or solely DISABLED if no
          scene modes are available. FACE_PRIORITY must be included
          if face detection is supported (i.e.`android.statistics.info.maxFaceCount &gt; 0`).
          </range>
          <details>
          This list contains scene modes that can be set for the camera device.
          Only scene modes that have been fully implemented for the
          camera device may be included here. Implementations are not expected
          to be consistent across all devices. If no scene modes are supported
          by the camera device, this will be set to `[DISABLED]`.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="availableVideoStabilizationModes" type="byte"
               visibility="public" type_notes="List of enums." container="array">
          <array>
            <size>n</size>
          </array>
          <description>List of video stabilization modes that can
          be supported</description>
          <range>OFF must be included</range>
          <tag id="BC" />
        </entry>
        <entry name="awbAvailableModes" type="byte" visibility="public"
               type_notes="List of enums"
               container="array">
          <array>
            <size>n</size>
          </array>
          <description>The set of auto-white-balance modes (android.control.awbMode)
          that are supported by this camera device.</description>
          <details>
          Not all the auto-white-balance modes may be supported by a
          given camera device. This entry lists the valid modes for
          android.control.awbMode for this camera device.

          All camera devices will support ON mode.

          FULL mode camera devices will always support OFF mode,
          which enables application control of white balance, by using
          android.colorCorrection.transform and android.colorCorrection.gains
          (android.colorCorrection.mode must be set to TRANSFORM_MATRIX).
          </details>
          <tag id="BC" />
        </entry>
        <entry name="maxRegions" type="int32" visibility="public" container="array">
          <array>
            <size>3</size>
          </array>
          <description>
          List of the maximum number of regions that can be used for metering in
          auto-exposure (AE), auto-white balance (AWB), and auto-focus (AF);
          this corresponds to the the maximum number of elements in
          android.control.aeRegions, android.control.awbRegions,
          and android.control.afRegions.
          </description>
          <range>
          Value must be &amp;gt;= 0 for each element. For full-capability devices
          this value must be &amp;gt;= 1 for AE and AF. The order of the elements is:
          `(AE, AWB, AF)`.</range>
          <tag id="BC" />
        </entry>
        <entry name="sceneModeOverrides" type="byte" visibility="system"
               container="array">
          <array>
            <size>3</size>
            <size>length(availableSceneModes)</size>
          </array>
          <description>
          Ordered list of auto-exposure, auto-white balance, and auto-focus
          settings to use with each available scene mode.
          </description>
          <range>
          For each available scene mode, the list must contain three
          entries containing the android.control.aeMode,
          android.control.awbMode, and android.control.afMode values used
          by the camera device. The entry order is `(aeMode, awbMode, afMode)`
          where aeMode has the lowest index position.
          </range>
          <details>
          When a scene mode is enabled, the camera device is expected
          to override android.control.aeMode, android.control.awbMode,
          and android.control.afMode with its preferred settings for
          that scene mode.

          The order of this list matches that of availableSceneModes,
          with 3 entries for each mode.  The overrides listed
          for FACE_PRIORITY are ignored, since for that
          mode the application-set android.control.aeMode,
          android.control.awbMode, and android.control.afMode values are
          used instead, matching the behavior when android.control.mode
          is set to AUTO. It is recommended that the FACE_PRIORITY
          overrides should be set to 0.

          For example, if availableSceneModes contains
          `(FACE_PRIORITY, ACTION, NIGHT)`,  then the camera framework
          expects sceneModeOverrides to have 9 entries formatted like:
          `(0, 0, 0, ON_AUTO_FLASH, AUTO, CONTINUOUS_PICTURE,
          ON_AUTO_FLASH, INCANDESCENT, AUTO)`.
          </details>
          <hal_details>
          To maintain backward compatibility, this list will be made available
          in the static metadata of the camera service.  The camera service will
          use these values to set android.control.aeMode,
          android.control.awbMode, and android.control.afMode when using a scene
          mode other than FACE_PRIORITY.
          </hal_details>
          <tag id="BC" />
        </entry>
      </static>
      <dynamic>
        <entry name="aePrecaptureId" type="int32" visibility="hidden">
          <description>The ID sent with the latest
          CAMERA2_TRIGGER_PRECAPTURE_METERING call</description>
          <range>**Deprecated**. Do not use.</range>
          <details>Must be 0 if no
          CAMERA2_TRIGGER_PRECAPTURE_METERING trigger received yet
          by HAL. Always updated even if AE algorithm ignores the
          trigger</details>
        </entry>
        <clone entry="android.control.aeAntibandingMode" kind="controls">
        </clone>
        <clone entry="android.control.aeExposureCompensation" kind="controls">
        </clone>
        <clone entry="android.control.aeLock" kind="controls">
        </clone>
        <clone entry="android.control.aeMode" kind="controls">
        </clone>
        <clone entry="android.control.aeRegions" kind="controls">
        </clone>
        <clone entry="android.control.aeTargetFpsRange" kind="controls">
        </clone>
        <clone entry="android.control.aePrecaptureTrigger" kind="controls">
        </clone>
        <entry name="aeState" type="byte" visibility="public" enum="true">
          <enum>
            <value>INACTIVE
            <notes>AE is off or recently reset. When a camera device is opened, it starts in
            this state. This is a transient state, the camera device may skip reporting
            this state in capture result.</notes></value>
            <value>SEARCHING
            <notes>AE doesn't yet have a good set of control values
            for the current scene. This is a transient state, the camera device may skip
            reporting this state in capture result.</notes></value>
            <value>CONVERGED
            <notes>AE has a good set of control values for the
            current scene.</notes></value>
            <value>LOCKED
            <notes>AE has been locked.</notes></value>
            <value>FLASH_REQUIRED
            <notes>AE has a good set of control values, but flash
            needs to be fired for good quality still
            capture.</notes></value>
            <value>PRECAPTURE
            <notes>AE has been asked to do a precapture sequence
            (through the android.control.aePrecaptureTrigger START),
            and is currently executing it. Once PRECAPTURE
            completes, AE will transition to CONVERGED or
            FLASH_REQUIRED as appropriate. This is a transient state, the
            camera device may skip reporting this state in capture result.</notes></value>
          </enum>
          <description>Current state of AE algorithm</description>
          <details>Switching between or enabling AE modes (android.control.aeMode) always
          resets the AE state to INACTIVE. Similarly, switching between android.control.mode,
          or android.control.sceneMode if `android.control.mode == USE_SCENE_MODE` resets all
          the algorithm states to INACTIVE.

          The camera device can do several state transitions between two results, if it is
          allowed by the state transition table. For example: INACTIVE may never actually be
          seen in a result.

          The state in the result is the state for this image (in sync with this image): if
          AE state becomes CONVERGED, then the image data associated with this result should
          be good to use.

          Below are state transition tables for different AE modes.

            State       | Transition Cause | New State | Notes
          :------------:|:----------------:|:---------:|:-----------------------:
          INACTIVE      |                  | INACTIVE  | Camera device auto exposure algorithm is disabled

          When android.control.aeMode is AE_MODE_ON_*:

            State        | Transition Cause                             | New State      | Notes
          :-------------:|:--------------------------------------------:|:--------------:|:-----------------:
          INACTIVE       | Camera device initiates AE scan              | SEARCHING      | Values changing
          INACTIVE       | android.control.aeLock is ON                 | LOCKED         | Values locked
          SEARCHING      | Camera device finishes AE scan               | CONVERGED      | Good values, not changing
          SEARCHING      | Camera device finishes AE scan               | FLASH_REQUIRED | Converged but too dark w/o flash
          SEARCHING      | android.control.aeLock is ON                 | LOCKED         | Values locked
          CONVERGED      | Camera device initiates AE scan              | SEARCHING      | Values changing
          CONVERGED      | android.control.aeLock is ON                 | LOCKED         | Values locked
          FLASH_REQUIRED | Camera device initiates AE scan              | SEARCHING      | Values changing
          FLASH_REQUIRED | android.control.aeLock is ON                 | LOCKED         | Values locked
          LOCKED         | android.control.aeLock is OFF                | SEARCHING      | Values not good after unlock
          LOCKED         | android.control.aeLock is OFF                | CONVERGED      | Values good after unlock
          LOCKED         | android.control.aeLock is OFF                | FLASH_REQUIRED | Exposure good, but too dark
          PRECAPTURE     | Sequence done. android.control.aeLock is OFF | CONVERGED      | Ready for high-quality capture
          PRECAPTURE     | Sequence done. android.control.aeLock is ON  | LOCKED         | Ready for high-quality capture
          Any state      | android.control.aePrecaptureTrigger is START | PRECAPTURE     | Start AE precapture metering sequence

          For the above table, the camera device may skip reporting any state changes that happen
          without application intervention (i.e. mode switch, trigger, locking). Any state that
          can be skipped in that manner is called a transient state.

          For example, for above AE modes (AE_MODE_ON_*), in addition to the state transitions
          listed in above table, it is also legal for the camera device to skip one or more
          transient states between two results. See below table for examples:

            State        | Transition Cause                                            | New State      | Notes
          :-------------:|:-----------------------------------------------------------:|:--------------:|:-----------------:
          INACTIVE       | Camera device finished AE scan                              | CONVERGED      | Values are already good, transient states are skipped by camera device.
          Any state      | android.control.aePrecaptureTrigger is START, sequence done | FLASH_REQUIRED | Converged but too dark w/o flash after a precapture sequence, transient states are skipped by camera device.
          Any state      | android.control.aePrecaptureTrigger is START, sequence done | CONVERGED      | Converged after a precapture sequence, transient states are skipped by camera device.
          CONVERGED      | Camera device finished AE scan                              | FLASH_REQUIRED | Converged but too dark w/o flash after a new scan, transient states are skipped by camera device.
          FLASH_REQUIRED | Camera device finished AE scan                              | CONVERGED      | Converged after a new scan, transient states are skipped by camera device.
          </details>
        </entry>
        <clone entry="android.control.afMode" kind="controls">
        </clone>
        <clone entry="android.control.afRegions" kind="controls">
        </clone>
        <clone entry="android.control.afTrigger" kind="controls">
        </clone>
        <entry name="afState" type="byte" visibility="public" enum="true">
          <enum>
            <value>INACTIVE
            <notes>AF off or has not yet tried to scan/been asked
            to scan.  When a camera device is opened, it starts in
            this state. This is a transient state, the camera device may
            skip reporting this state in capture result.</notes></value>
            <value>PASSIVE_SCAN
            <notes>if CONTINUOUS_* modes are supported. AF is
            currently doing an AF scan initiated by a continuous
            autofocus mode. This is a transient state, the camera device may
            skip reporting this state in capture result.</notes></value>
            <value>PASSIVE_FOCUSED
            <notes>if CONTINUOUS_* modes are supported. AF currently
            believes it is in focus, but may restart scanning at
            any time. This is a transient state, the camera device may skip
            reporting this state in capture result.</notes></value>
            <value>ACTIVE_SCAN
            <notes>if AUTO or MACRO modes are supported. AF is doing
            an AF scan because it was triggered by AF trigger. This is a
            transient state, the camera device may skip reporting
            this state in capture result.</notes></value>
            <value>FOCUSED_LOCKED
            <notes>if any AF mode besides OFF is supported. AF
            believes it is focused correctly and is
            locked.</notes></value>
            <value>NOT_FOCUSED_LOCKED
            <notes>if any AF mode besides OFF is supported. AF has
            failed to focus successfully and is
            locked.</notes></value>
            <value>PASSIVE_UNFOCUSED
            <notes>if CONTINUOUS_* modes are supported. AF finished a
            passive scan without finding focus, and may restart
            scanning at any time. This is a transient state, the camera
            device may skip reporting this state in capture result.</notes></value>
          </enum>
          <description>Current state of AF algorithm.</description>
          <details>
          Switching between or enabling AF modes (android.control.afMode) always
          resets the AF state to INACTIVE. Similarly, switching between android.control.mode,
          or android.control.sceneMode if `android.control.mode == USE_SCENE_MODE` resets all
          the algorithm states to INACTIVE.

          The camera device can do several state transitions between two results, if it is
          allowed by the state transition table. For example: INACTIVE may never actually be
          seen in a result.

          The state in the result is the state for this image (in sync with this image): if
          AF state becomes FOCUSED, then the image data associated with this result should
          be sharp.

          Below are state transition tables for different AF modes.

          When android.control.afMode is AF_MODE_OFF or AF_MODE_EDOF:

            State       | Transition Cause | New State | Notes
          :------------:|:----------------:|:---------:|:-----------:
          INACTIVE      |                  | INACTIVE  | Never changes

          When android.control.afMode is AF_MODE_AUTO or AF_MODE_MACRO:

            State            | Transition Cause | New State          | Notes
          :-----------------:|:----------------:|:------------------:|:--------------:
          INACTIVE           | AF_TRIGGER       | ACTIVE_SCAN        | Start AF sweep, Lens now moving
          ACTIVE_SCAN        | AF sweep done    | FOCUSED_LOCKED     | Focused, Lens now locked
          ACTIVE_SCAN        | AF sweep done    | NOT_FOCUSED_LOCKED | Not focused, Lens now locked
          ACTIVE_SCAN        | AF_CANCEL        | INACTIVE           | Cancel/reset AF, Lens now locked
          FOCUSED_LOCKED     | AF_CANCEL        | INACTIVE           | Cancel/reset AF
          FOCUSED_LOCKED     | AF_TRIGGER       | ACTIVE_SCAN        | Start new sweep, Lens now moving
          NOT_FOCUSED_LOCKED | AF_CANCEL        | INACTIVE           | Cancel/reset AF
          NOT_FOCUSED_LOCKED | AF_TRIGGER       | ACTIVE_SCAN        | Start new sweep, Lens now moving
          Any state          | Mode change      | INACTIVE           |

          For the above table, the camera device may skip reporting any state changes that happen
          without application intervention (i.e. mode switch, trigger, locking). Any state that
          can be skipped in that manner is called a transient state.

          For example, for these AF modes (AF_MODE_AUTO and AF_MODE_MACRO), in addition to the
          state transitions listed in above table, it is also legal for the camera device to skip
          one or more transient states between two results. See below table for examples:

            State            | Transition Cause | New State          | Notes
          :-----------------:|:----------------:|:------------------:|:--------------:
          INACTIVE           | AF_TRIGGER       | FOCUSED_LOCKED     | Focus is already good or good after a scan, lens is now locked.
          INACTIVE           | AF_TRIGGER       | NOT_FOCUSED_LOCKED | Focus failed after a scan, lens is now locked.
          FOCUSED_LOCKED     | AF_TRIGGER       | FOCUSED_LOCKED     | Focus is already good or good after a scan, lens is now locked.
          NOT_FOCUSED_LOCKED | AF_TRIGGER       | FOCUSED_LOCKED     | Focus is good after a scan, lens is not locked.


          When android.control.afMode is AF_MODE_CONTINUOUS_VIDEO:

            State            | Transition Cause                    | New State          | Notes
          :-----------------:|:-----------------------------------:|:------------------:|:--------------:
          INACTIVE           | Camera device initiates new scan    | PASSIVE_SCAN       | Start AF scan, Lens now moving
          INACTIVE           | AF_TRIGGER                          | NOT_FOCUSED_LOCKED | AF state query, Lens now locked
          PASSIVE_SCAN       | Camera device completes current scan| PASSIVE_FOCUSED    | End AF scan, Lens now locked
          PASSIVE_SCAN       | Camera device fails current scan    | PASSIVE_UNFOCUSED  | End AF scan, Lens now locked
          PASSIVE_SCAN       | AF_TRIGGER                          | FOCUSED_LOCKED     | Immediate trans. If focus is good, Lens now locked
          PASSIVE_SCAN       | AF_TRIGGER                          | NOT_FOCUSED_LOCKED | Immediate trans. if focus is bad, Lens now locked
          PASSIVE_SCAN       | AF_CANCEL                           | INACTIVE           | Reset lens position, Lens now locked
          PASSIVE_FOCUSED    | Camera device initiates new scan    | PASSIVE_SCAN       | Start AF scan, Lens now moving
          PASSIVE_UNFOCUSED  | Camera device initiates new scan    | PASSIVE_SCAN       | Start AF scan, Lens now moving
          PASSIVE_FOCUSED    | AF_TRIGGER                          | FOCUSED_LOCKED     | Immediate trans. Lens now locked
          PASSIVE_UNFOCUSED  | AF_TRIGGER                          | NOT_FOCUSED_LOCKED | Immediate trans. Lens now locked
          FOCUSED_LOCKED     | AF_TRIGGER                          | FOCUSED_LOCKED     | No effect
          FOCUSED_LOCKED     | AF_CANCEL                           | INACTIVE           | Restart AF scan
          NOT_FOCUSED_LOCKED | AF_TRIGGER                          | NOT_FOCUSED_LOCKED | No effect
          NOT_FOCUSED_LOCKED | AF_CANCEL                           | INACTIVE           | Restart AF scan

          When android.control.afMode is AF_MODE_CONTINUOUS_PICTURE:

            State            | Transition Cause                     | New State          | Notes
          :-----------------:|:------------------------------------:|:------------------:|:--------------:
          INACTIVE           | Camera device initiates new scan     | PASSIVE_SCAN       | Start AF scan, Lens now moving
          INACTIVE           | AF_TRIGGER                           | NOT_FOCUSED_LOCKED | AF state query, Lens now locked
          PASSIVE_SCAN       | Camera device completes current scan | PASSIVE_FOCUSED    | End AF scan, Lens now locked
          PASSIVE_SCAN       | Camera device fails current scan     | PASSIVE_UNFOCUSED  | End AF scan, Lens now locked
          PASSIVE_SCAN       | AF_TRIGGER                           | FOCUSED_LOCKED     | Eventual trans. once focus good, Lens now locked
          PASSIVE_SCAN       | AF_TRIGGER                           | NOT_FOCUSED_LOCKED | Eventual trans. if cannot focus, Lens now locked
          PASSIVE_SCAN       | AF_CANCEL                            | INACTIVE           | Reset lens position, Lens now locked
          PASSIVE_FOCUSED    | Camera device initiates new scan     | PASSIVE_SCAN       | Start AF scan, Lens now moving
          PASSIVE_UNFOCUSED  | Camera device initiates new scan     | PASSIVE_SCAN       | Start AF scan, Lens now moving
          PASSIVE_FOCUSED    | AF_TRIGGER                           | FOCUSED_LOCKED     | Immediate trans. Lens now locked
          PASSIVE_UNFOCUSED  | AF_TRIGGER                           | NOT_FOCUSED_LOCKED | Immediate trans. Lens now locked
          FOCUSED_LOCKED     | AF_TRIGGER                           | FOCUSED_LOCKED     | No effect
          FOCUSED_LOCKED     | AF_CANCEL                            | INACTIVE           | Restart AF scan
          NOT_FOCUSED_LOCKED | AF_TRIGGER                           | NOT_FOCUSED_LOCKED | No effect
          NOT_FOCUSED_LOCKED | AF_CANCEL                            | INACTIVE           | Restart AF scan

          When switch between AF_MODE_CONTINUOUS_* (CAF modes) and AF_MODE_AUTO/AF_MODE_MACRO
          (AUTO modes), the initial INACTIVE or PASSIVE_SCAN states may be skipped by the
          camera device. When a trigger is included in a mode switch request, the trigger
          will be evaluated in the context of the new mode in the request.
          See below table for examples:

            State      | Transition Cause                       | New State                                | Notes
          :-----------:|:--------------------------------------:|:----------------------------------------:|:--------------:
          any state    | CAF-->AUTO mode switch                 | INACTIVE                                 | Mode switch without trigger, initial state must be INACTIVE
          any state    | CAF-->AUTO mode switch with AF_TRIGGER | trigger-reachable states from INACTIVE   | Mode switch with trigger, INACTIVE is skipped
          any state    | AUTO-->CAF mode switch                 | passively reachable states from INACTIVE | Mode switch without trigger, passive transient state is skipped
          </details>
        </entry>
        <entry name="afTriggerId" type="int32" visibility="hidden">
          <description>The ID sent with the latest
          CAMERA2_TRIGGER_AUTOFOCUS call</description>
          <range>**Deprecated**. Do not use.</range>
          <details>Must be 0 if no CAMERA2_TRIGGER_AUTOFOCUS trigger
          received yet by HAL. Always updated even if AF algorithm
          ignores the trigger</details>
        </entry>
        <clone entry="android.control.awbLock" kind="controls">
        </clone>
        <clone entry="android.control.awbMode" kind="controls">
        </clone>
        <clone entry="android.control.awbRegions" kind="controls">
        </clone>
        <clone entry="android.control.captureIntent" kind="controls">
        </clone>
        <entry name="awbState" type="byte" visibility="public" enum="true">
          <enum>
            <value>INACTIVE
            <notes>AWB is not in auto mode.  When a camera device is opened, it
            starts in this state. This is a transient state, the camera device may
            skip reporting this state in capture result.</notes></value>
            <value>SEARCHING
            <notes>AWB doesn't yet have a good set of control
            values for the current scene. This is a transient state, the camera device
            may skip reporting this state in capture result.</notes></value>
            <value>CONVERGED
            <notes>AWB has a good set of control values for the
            current scene.</notes></value>
            <value>LOCKED
            <notes>AWB has been locked.
            </notes></value>
          </enum>
          <description>Current state of AWB algorithm</description>
          <details>Switching between or enabling AWB modes (android.control.awbMode) always
          resets the AWB state to INACTIVE. Similarly, switching between android.control.mode,
          or android.control.sceneMode if `android.control.mode == USE_SCENE_MODE` resets all
          the algorithm states to INACTIVE.

          The camera device can do several state transitions between two results, if it is
          allowed by the state transition table. So INACTIVE may never actually be seen in
          a result.

          The state in the result is the state for this image (in sync with this image): if
          AWB state becomes CONVERGED, then the image data associated with this result should
          be good to use.

          Below are state transition tables for different AWB modes.

          When `android.control.awbMode != AWB_MODE_AUTO`:

            State       | Transition Cause | New State | Notes
          :------------:|:----------------:|:---------:|:-----------------------:
          INACTIVE      |                  |INACTIVE   |Camera device auto white balance algorithm is disabled

          When android.control.awbMode is AWB_MODE_AUTO:

            State        | Transition Cause                 | New State     | Notes
          :-------------:|:--------------------------------:|:-------------:|:-----------------:
          INACTIVE       | Camera device initiates AWB scan | SEARCHING     | Values changing
          INACTIVE       | android.control.awbLock is ON    | LOCKED        | Values locked
          SEARCHING      | Camera device finishes AWB scan  | CONVERGED     | Good values, not changing
          SEARCHING      | android.control.awbLock is ON    | LOCKED        | Values locked
          CONVERGED      | Camera device initiates AWB scan | SEARCHING     | Values changing
          CONVERGED      | android.control.awbLock is ON    | LOCKED        | Values locked
          LOCKED         | android.control.awbLock is OFF   | SEARCHING     | Values not good after unlock

          For the above table, the camera device may skip reporting any state changes that happen
          without application intervention (i.e. mode switch, trigger, locking). Any state that
          can be skipped in that manner is called a transient state.

          For example, for this AWB mode (AWB_MODE_AUTO), in addition to the state transitions
          listed in above table, it is also legal for the camera device to skip one or more
          transient states between two results. See below table for examples:

            State        | Transition Cause                 | New State     | Notes
          :-------------:|:--------------------------------:|:-------------:|:-----------------:
          INACTIVE       | Camera device finished AWB scan  | CONVERGED     | Values are already good, transient states are skipped by camera device.
          LOCKED         | android.control.awbLock is OFF   | CONVERGED     | Values good after unlock, transient states are skipped by camera device.
          </details>
        </entry>
        <clone entry="android.control.effectMode" kind="controls">
        </clone>
        <clone entry="android.control.mode" kind="controls">
        </clone>
        <clone entry="android.control.sceneMode" kind="controls">
        </clone>
        <clone entry="android.control.videoStabilizationMode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="demosaic">
      <controls>
        <entry name="mode" type="byte" enum="true">
          <enum>
            <value>FAST
            <notes>Minimal or no slowdown of frame rate compared to
            Bayer RAW output</notes></value>
            <value>HIGH_QUALITY
            <notes>High-quality may reduce output frame
            rate</notes></value>
          </enum>
          <description>Controls the quality of the demosaicing
          processing</description>
          <tag id="V1" />
        </entry>
      </controls>
    </section>
    <section name="edge">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>No edge enhancement is applied</notes></value>
            <value>FAST
            <notes>Must not slow down frame rate relative to sensor
            output</notes></value>
            <value>HIGH_QUALITY
            <notes>Frame rate may be reduced by high
            quality</notes></value>
          </enum>
          <description>Operation mode for edge
          enhancement.</description>
          <details>Edge/sharpness/detail enhancement. OFF means no
          enhancement will be applied by the camera device.

          This must be set to one of the modes listed in android.edge.availableEdgeModes.

          FAST/HIGH_QUALITY both mean camera device determined enhancement
          will be applied. HIGH_QUALITY mode indicates that the
          camera device will use the highest-quality enhancement algorithms,
          even if it slows down capture rate. FAST means the camera device will
          not slow down capture rate when applying edge enhancement.</details>
          <tag id="V1" />
        </entry>
        <entry name="strength" type="byte">
          <description>Control the amount of edge enhancement
          applied to the images</description>
          <units>1-10; 10 is maximum sharpening</units>
          <tag id="V1" />
        </entry>
      </controls>
      <static>
        <entry name="availableEdgeModes" type="byte" visibility="public"
        type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>
          The set of edge enhancement modes supported by this camera device.
          </description>
          <details>
          This tag lists the valid modes for android.edge.mode.

          Full-capability camera devices must always support OFF and FAST.
          </details>
          <tag id="V1" />
        </entry>
      </static>
      <dynamic>
        <clone entry="android.edge.mode" kind="controls">
          <tag id="V1" />
        </clone>
      </dynamic>
    </section>
    <section name="flash">
      <controls>
        <entry name="firingPower" type="byte">
          <description>Power for flash firing/torch</description>
          <units>10 is max power; 0 is no flash. Linear</units>
          <range>0 - 10</range>
          <details>Power for snapshot may use a different scale than
          for torch mode. Only one entry for torch mode will be
          used</details>
          <tag id="V1" />
        </entry>
        <entry name="firingTime" type="int64">
          <description>Firing time of flash relative to start of
          exposure</description>
          <units>nanoseconds</units>
          <range>0-(exposure time-flash duration)</range>
          <details>Clamped to (0, exposure time - flash
          duration).</details>
          <tag id="V1" />
        </entry>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
              Do not fire the flash for this capture.
              </notes>
            </value>
            <value>SINGLE
              <notes>
              If the flash is available and charged, fire flash
              for this capture based on android.flash.firingPower and
              android.flash.firingTime.
              </notes>
            </value>
            <value>TORCH
              <notes>
              Transition flash to continuously on.
              </notes>
            </value>
          </enum>
          <description>The desired mode for for the camera device's flash control.</description>
          <details>
          This control is only effective when flash unit is available
          (`android.flash.info.available == true`).

          When this control is used, the android.control.aeMode must be set to ON or OFF.
          Otherwise, the camera device auto-exposure related flash control (ON_AUTO_FLASH,
          ON_ALWAYS_FLASH, or ON_AUTO_FLASH_REDEYE) will override this control.

          When set to OFF, the camera device will not fire flash for this capture.

          When set to SINGLE, the camera device will fire flash regardless of the camera
          device's auto-exposure routine's result. When used in still capture case, this
          control should be used along with AE precapture metering sequence
          (android.control.aePrecaptureTrigger), otherwise, the image may be incorrectly exposed.

          When set to TORCH, the flash will be on continuously. This mode can be used
          for use cases such as preview, auto-focus assist, still capture, or video recording.

          The flash status will be reported by android.flash.state in the capture result metadata.
          </details>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="available" type="byte" visibility="public" enum="true" typedef="boolean">
            <enum>
              <value>FALSE</value>
              <value>TRUE</value>
            </enum>
            <description>Whether this camera device has a
            flash.</description>
            <details>If no flash, none of the flash controls do
            anything. All other metadata should return 0.</details>
            <tag id="BC" />
          </entry>
          <entry name="chargeDuration" type="int64">
            <description>Time taken before flash can fire
            again</description>
            <units>nanoseconds</units>
            <range>0-1e9</range>
            <details>1 second too long/too short for recharge? Should
            this be power-dependent?</details>
            <tag id="V1" />
          </entry>
        </namespace>
        <entry name="colorTemperature" type="byte">
          <description>The x,y whitepoint of the
          flash</description>
          <units>pair of floats</units>
          <range>0-1 for both</range>
          <tag id="ADV" />
        </entry>
        <entry name="maxEnergy" type="byte">
          <description>Max energy output of the flash for a full
          power single flash</description>
          <units>lumen-seconds</units>
          <range>&amp;gt;= 0</range>
          <tag id="ADV" />
        </entry>
      </static>
      <dynamic>
        <clone entry="android.flash.firingPower" kind="controls">
        </clone>
        <clone entry="android.flash.firingTime" kind="controls">
        </clone>
        <clone entry="android.flash.mode" kind="controls"></clone>
        <entry name="state" type="byte" visibility="public" enum="true">
          <enum>
            <value>UNAVAILABLE
            <notes>No flash on camera.</notes></value>
            <value>CHARGING
            <notes>Flash is charging and cannot be fired.</notes></value>
            <value>READY
            <notes>Flash is ready to fire.</notes></value>
            <value>FIRED
            <notes>Flash fired for this capture.</notes></value>
            <value>PARTIAL
            <notes>Flash partially illuminated this frame. This is usually due to the next
            or previous frame having the flash fire, and the flash spilling into this capture
            due to hardware limitations.</notes></value>
          </enum>
          <description>Current state of the flash
          unit.</description>
          <details>
          When the camera device doesn't have flash unit
          (i.e. `android.flash.info.available == false`), this state will always be UNAVAILABLE.
          Other states indicate the current flash status.
          </details>
        </entry>
      </dynamic>
    </section>
    <section name="hotPixel">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>
              The frame rate must not be reduced relative to sensor raw output
              for this option.

              No hot pixel correction is applied.
              The hotpixel map may be returned in android.statistics.hotPixelMap.
              </notes>
            </value>
            <value>FAST
              <notes>
              The frame rate must not be reduced relative to sensor raw output
              for this option.

              Hot pixel correction is applied.
              The hotpixel map may be returned in android.statistics.hotPixelMap.
              </notes>
            </value>
            <value>HIGH_QUALITY
              <notes>
              The frame rate may be reduced relative to sensor raw output
              for this option.

              A high-quality hot pixel correction is applied.
              The hotpixel map may be returned in android.statistics.hotPixelMap.
              </notes>
            </value>
          </enum>
          <description>
          Set operational mode for hot pixel correction.
          </description>
          <details>
          Valid modes for this camera device are listed in
          android.hotPixel.availableHotPixelModes.

          Hotpixel correction interpolates out, or otherwise removes, pixels
          that do not accurately encode the incoming light (i.e. pixels that
          are stuck at an arbitrary value).
          </details>
          <tag id="V1" />
          <tag id="DNG" />
        </entry>
      </controls>
      <static>
        <entry name="availableHotPixelModes" type="byte" visibility="public"
          type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>
          The set of hot pixel correction modes that are supported by this
          camera device.
          </description>
          <details>
          This tag lists valid modes for android.hotPixel.mode.

          FULL mode camera devices will always support FAST.
          </details>
          <hal_details>
          To avoid performance issues, there will be significantly fewer hot
          pixels than actual pixels on the camera sensor.
          </hal_details>
          <tag id="ADV" />
          <tag id="V1" />
          <tag id="DNG" />
        </entry>
      </static>
      <dynamic>
        <clone entry="android.hotPixel.mode" kind="controls">
          <tag id="V1" />
          <tag id="DNG" />
        </clone>
      </dynamic>
    </section>
    <section name="jpeg">
      <controls>
        <entry name="gpsCoordinates" type="double" visibility="public"
        type_notes="latitude, longitude, altitude. First two in degrees, the third in meters"
        container="array">
          <array>
            <size>3</size>
          </array>
          <description>GPS coordinates to include in output JPEG
          EXIF</description>
          <range>(-180 - 180], [-90,90], [-inf, inf]</range>
          <tag id="BC" />
        </entry>
        <entry name="gpsProcessingMethod" type="byte" visibility="public"
               typedef="string">
          <description>32 characters describing GPS algorithm to
          include in EXIF</description>
          <units>UTF-8 null-terminated string</units>
          <tag id="BC" />
        </entry>
        <entry name="gpsTimestamp" type="int64" visibility="public">
          <description>Time GPS fix was made to include in
          EXIF</description>
          <units>UTC in seconds since January 1, 1970</units>
          <tag id="BC" />
        </entry>
        <entry name="orientation" type="int32" visibility="public">
          <description>Orientation of JPEG image to
          write</description>
          <units>Degrees in multiples of 90</units>
          <range>0, 90, 180, 270</range>
          <tag id="BC" />
        </entry>
        <entry name="quality" type="byte" visibility="public">
          <description>Compression quality of the final JPEG
          image</description>
          <range>1-100; larger is higher quality</range>
          <details>85-95 is typical usage range</details>
          <tag id="BC" />
        </entry>
        <entry name="thumbnailQuality" type="byte" visibility="public">
          <description>Compression quality of JPEG
          thumbnail</description>
          <range>1-100; larger is higher quality</range>
          <tag id="BC" />
        </entry>
        <entry name="thumbnailSize" type="int32" visibility="public"
        container="array" typedef="size">
          <array>
            <size>2</size>
          </array>
          <description>Resolution of embedded JPEG thumbnail</description>
          <range>Size must be one of the size from android.jpeg.availableThumbnailSizes</range>
          <details>When set to (0, 0) value, the JPEG EXIF will not contain thumbnail,
          but the captured JPEG will still be a valid image.

          When a jpeg image capture is issued, the thumbnail size selected should have
          the same aspect ratio as the jpeg image.</details>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <entry name="availableThumbnailSizes" type="int32" visibility="public"
        container="array" typedef="size">
          <array>
            <size>2</size>
            <size>n</size>
          </array>
          <description>Supported resolutions for the JPEG thumbnail</description>
          <range>Will include at least one valid resolution, plus
          (0,0) for no thumbnail generation, and each size will be distinct.</range>
          <details>Below condiditions will be satisfied for this size list:

          * The sizes will be sorted by increasing pixel area (width x height).
          If several resolutions have the same area, they will be sorted by increasing width.
          * The aspect ratio of the largest thumbnail size will be same as the
          aspect ratio of largest JPEG output size in android.scaler.availableStreamConfigurations.
          The largest size is defined as the size that has the largest pixel area
          in a given size list.
          * Each output JPEG size in android.scaler.availableStreamConfigurations will have at least
          one corresponding size that has the same aspect ratio in availableThumbnailSizes,
          and vice versa.
          * All non (0, 0) sizes will have non-zero widths and heights.</details>
          <tag id="BC" />
        </entry>
        <entry name="maxSize" type="int32" visibility="system">
          <description>Maximum size in bytes for the compressed
          JPEG buffer</description>
          <range>Must be large enough to fit any JPEG produced by
          the camera</range>
          <details>This is used for sizing the gralloc buffers for
          JPEG</details>
        </entry>
      </static>
      <dynamic>
        <clone entry="android.jpeg.gpsCoordinates" kind="controls">
        </clone>
        <clone entry="android.jpeg.gpsProcessingMethod"
        kind="controls"></clone>
        <clone entry="android.jpeg.gpsTimestamp" kind="controls">
        </clone>
        <clone entry="android.jpeg.orientation" kind="controls">
        </clone>
        <clone entry="android.jpeg.quality" kind="controls">
        </clone>
        <entry name="size" type="int32">
          <description>The size of the compressed JPEG image, in
          bytes</description>
          <range>&amp;gt;= 0</range>
          <details>If no JPEG output is produced for the request,
          this must be 0.

          Otherwise, this describes the real size of the compressed
          JPEG image placed in the output stream.  More specifically,
          if android.jpeg.maxSize = 1000000, and a specific capture
          has android.jpeg.size = 500000, then the output buffer from
          the JPEG stream will be 1000000 bytes, of which the first
          500000 make up the real data.</details>
        </entry>
        <clone entry="android.jpeg.thumbnailQuality"
        kind="controls"></clone>
        <clone entry="android.jpeg.thumbnailSize" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="lens">
      <controls>
        <entry name="aperture" type="float" visibility="public">
          <description>The ratio of lens focal length to the effective
          aperture diameter.</description>
          <units>f-number (f/NNN)</units>
          <range>android.lens.info.availableApertures</range>
          <details>This will only be supported on the camera devices that
          have variable aperture lens. The aperture value can only be
          one of the values listed in android.lens.info.availableApertures.

          When this is supported and android.control.aeMode is OFF,
          this can be set along with android.sensor.exposureTime,
          android.sensor.sensitivity, and android.sensor.frameDuration
          to achieve manual exposure control.

          The requested aperture value may take several frames to reach the
          requested value; the camera device will report the current (intermediate)
          aperture size in capture result metadata while the aperture is changing.
          While the aperture is still changing, android.lens.state will be set to MOVING.

          When this is supported and android.control.aeMode is one of
          the ON modes, this will be overridden by the camera device
          auto-exposure algorithm, the overridden values are then provided
          back to the user in the corresponding result.</details>
          <tag id="V1" />
        </entry>
        <entry name="filterDensity" type="float" visibility="public">
          <description>
          State of lens neutral density filter(s).
          </description>
          <units>Steps of Exposure Value (EV).</units>
          <range>android.lens.info.availableFilterDensities</range>
          <details>
          This will not be supported on most camera devices. On devices
          where this is supported, this may only be set to one of the
          values included in android.lens.info.availableFilterDensities.

          Lens filters are typically used to lower the amount of light the
          sensor is exposed to (measured in steps of EV). As used here, an EV
          step is the standard logarithmic representation, which are
          non-negative, and inversely proportional to the amount of light
          hitting the sensor.  For example, setting this to 0 would result
          in no reduction of the incoming light, and setting this to 2 would
          mean that the filter is set to reduce incoming light by two stops
          (allowing 1/4 of the prior amount of light to the sensor).

          It may take several frames before the lens filter density changes
          to the requested value. While the filter density is still changing,
          android.lens.state will be set to MOVING.
          </details>
          <tag id="V1" />
        </entry>
        <entry name="focalLength" type="float" visibility="public">
          <description>
          The current lens focal length; used for optical zoom.
          </description>
          <units>focal length in mm</units>
          <range>android.lens.info.availableFocalLengths</range>
          <details>
          This setting controls the physical focal length of the camera
          device's lens. Changing the focal length changes the field of
          view of the camera device, and is usually used for optical zoom.

          Like android.lens.focusDistance and android.lens.aperture, this
          setting won't be applied instantaneously, and it may take several
          frames before the lens can change to the requested focal length.
          While the focal length is still changing, android.lens.state will
          be set to MOVING.

          This is expected not to be supported on most devices.
          </details>
          <tag id="V1" />
        </entry>
        <entry name="focusDistance" type="float" visibility="public">
          <description>Distance to plane of sharpest focus,
          measured from frontmost surface of the lens</description>
          <units>See android.lens.info.focusDistanceCalibration for details.</units>
          <range>&amp;gt;= 0</range>
          <details>0 means infinity focus. Used value will be clamped
          to [0, android.lens.info.minimumFocusDistance].

          Like android.lens.focalLength, this setting won't be applied
          instantaneously, and it may take several frames before the lens
          can move to the requested focus distance. While the lens is still moving,
          android.lens.state will be set to MOVING.
          </details>
          <tag id="BC" />
          <tag id="V1" />
        </entry>
        <entry name="opticalStabilizationMode" type="byte" visibility="public"
        enum="true">
          <enum>
            <value>OFF
              <notes>Optical stabilization is unavailable.</notes>
            </value>
            <value optional="true">ON
              <notes>Optical stabilization is enabled.</notes>
            </value>
          </enum>
          <description>
          Sets whether the camera device uses optical image stabilization (OIS)
          when capturing images.
          </description>
          <range>android.lens.info.availableOpticalStabilization</range>
          <details>
          OIS is used to compensate for motion blur due to small movements of
          the camera during capture. Unlike digital image stabilization, OIS makes
          use of mechanical elements to stabilize the camera sensor, and thus
          allows for longer exposure times before camera shake becomes
          apparent.

          This is not expected to be supported on most devices.
          </details>
          <tag id="V1" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="availableApertures" type="float" visibility="public"
          container="array">
            <array>
              <size>n</size>
            </array>
            <description>List of supported aperture
            values.</description>
            <range>one entry required, &amp;gt; 0</range>
            <details>If the camera device doesn't support variable apertures,
            listed value will be the fixed aperture.

            If the camera device supports variable apertures, the aperture value
            in this list will be sorted in ascending order.</details>
            <tag id="V1" />
          </entry>
          <entry name="availableFilterDensities" type="float" visibility="public"
          container="array">
            <array>
              <size>n</size>
            </array>
            <description>
            List of supported neutral density filter values for
            android.lens.filterDensity.
            </description>
            <range>
            At least one value is required. Values must be &amp;gt;= 0.
            </range>
            <details>
            If changing android.lens.filterDensity is not supported,
            availableFilterDensities must contain only 0. Otherwise, this
            list contains only the exact filter density values available on
            this camera device.
            </details>
            <tag id="V1" />
          </entry>
          <entry name="availableFocalLengths" type="float" visibility="public"
          type_notes="The list of available focal lengths"
          container="array">
            <array>
              <size>n</size>
            </array>
            <description>
            The available focal lengths for this device for use with
            android.lens.focalLength.
            </description>
            <range>
            Each value in this list must be &amp;gt; 0. This list must
            contain at least one value.
            </range>
            <details>
            If optical zoom is not supported, this will only report
            a single value corresponding to the static focal length of the
            device. Otherwise, this will report every focal length supported
            by the device.
            </details>
            <tag id="BC" />
            <tag id="V1" />
          </entry>
          <entry name="availableOpticalStabilization" type="byte"
          visibility="public" type_notes="list of enums" container="array">
            <array>
              <size>n</size>
            </array>
            <description>
            List containing a subset of the optical image
            stabilization (OIS) modes specified in
            android.lens.opticalStabilizationMode.
            </description>
            <details>
            If OIS is not implemented for a given camera device, this should
            contain only OFF.
            </details>
            <tag id="V1" />
          </entry>
          <entry name="hyperfocalDistance" type="float" visibility="public" optional="true">
            <description>Optional. Hyperfocal distance for this lens.</description>
            <units>See android.lens.info.focusDistanceCalibration for details.</units>
            <range>If lens is fixed focus, &amp;gt;= 0. If lens has focuser unit, the range is
            `(0, android.lens.info.minimumFocusDistance]`</range>
            <details>
            If the lens is not fixed focus, the camera device will report this
            field when android.lens.info.focusDistanceCalibration is APPROXIMATE or CALIBRATED.
            </details>
          </entry>
          <entry name="minimumFocusDistance" type="float" visibility="public">
            <description>Shortest distance from frontmost surface
            of the lens that can be focused correctly.</description>
            <units>See android.lens.info.focusDistanceCalibration for details.</units>
            <range>&amp;gt;= 0</range>
            <details>If the lens is fixed-focus, this should be
            0.</details>
            <tag id="V1" />
          </entry>
          <entry name="shadingMapSize" type="int32" visibility="public"
                 type_notes="width and height (N, M) of lens shading map provided by the camera device."
                 container="array" typedef="size">
            <array>
              <size>2</size>
            </array>
            <description>Dimensions of lens shading map.</description>
            <range>Both values &amp;gt;= 1</range>
            <details>
            The map should be on the order of 30-40 rows and columns, and
            must be smaller than 64x64.
            </details>
            <tag id="V1" />
          </entry>
          <entry name="focusDistanceCalibration" type="byte" visibility="public" enum="true">
            <enum>
              <value>UNCALIBRATED
                <notes>
                The lens focus distance is not accurate, and the units used for
                android.lens.focusDistance do not correspond to any physical units.
                Setting the lens to the same focus distance on separate occasions may
                result in a different real focus distance, depending on factors such
                as the orientation of the device, the age of the focusing mechanism,
                and the device temperature. The focus distance value will still be
                in the range of `[0, android.lens.info.minimumFocusDistance]`, where 0
                represents the farthest focus.
                </notes>
              </value>
              <value>APPROXIMATE
                <notes>
                The lens focus distance is measured in diopters. However, setting the lens
                to the same focus distance on separate occasions may result in a
                different real focus distance, depending on factors such as the
                orientation of the device, the age of the focusing mechanism, and
                the device temperature.
                </notes>
              </value>
              <value>CALIBRATED
                <notes>
                The lens focus distance is measured in diopters. The lens mechanism is
                calibrated so that setting the same focus distance is repeatable on
                multiple occasions with good accuracy, and the focus distance corresponds
                to the real physical distance to the plane of best focus.
                </notes>
              </value>
            </enum>
            <description>The lens focus distance calibration quality.</description>
            <details>
            The lens focus distance calibration quality determines the reliability of
            focus related metadata entries, i.e. android.lens.focusDistance,
            android.lens.focusRange, android.lens.info.hyperfocalDistance, and
            android.lens.info.minimumFocusDistance.
            </details>
          <tag id="V1" />
        </entry>
        </namespace>
        <entry name="facing" type="byte" visibility="public" enum="true">
          <enum>
            <value>FRONT</value>
            <value>BACK</value>
          </enum>
          <description>Direction the camera faces relative to
          device screen</description>
        </entry>
        <entry name="opticalAxisAngle" type="float"
        type_notes="degrees. First defines the angle of separation between the perpendicular to the screen and the camera optical axis. The second then defines the clockwise rotation of the optical axis from native device up."
        container="array">
          <array>
            <size>2</size>
          </array>
          <description>Relative angle of camera optical axis to the
          perpendicular axis from the display</description>
          <range>[0-90) for first angle, [0-360) for second</range>
          <details>Examples:

          (0,0) means that the camera optical axis
          is perpendicular to the display surface;

          (45,0) means that the camera points 45 degrees up when
          device is held upright;

          (45,90) means the camera points 45 degrees to the right when
          the device is held upright.

          Use FACING field to determine perpendicular outgoing
          direction</details>
          <tag id="ADV" />
        </entry>
        <entry name="position" type="float" container="array">
          <array>
            <size>3, location in mm, in the sensor coordinate
            system</size>
          </array>
          <description>Coordinates of camera optical axis on
          device</description>
          <tag id="V1" />
        </entry>
      </static>
      <dynamic>
        <clone entry="android.lens.aperture" kind="controls">
          <tag id="V1" />
        </clone>
        <clone entry="android.lens.filterDensity" kind="controls">
          <tag id="V1" />
        </clone>
        <clone entry="android.lens.focalLength" kind="controls">
          <tag id="BC" />
        </clone>
        <clone entry="android.lens.focusDistance" kind="controls">
          <details>Should be zero for fixed-focus cameras</details>
          <tag id="BC" />
        </clone>
        <entry name="focusRange" type="float" visibility="public"
        type_notes="Range of scene distances that are in focus"
        container="array">
          <array>
            <size>2</size>
          </array>
          <description>The range of scene distances that are in
          sharp focus (depth of field)</description>
          <units>pair of focus distances in diopters: (near,
          far), see android.lens.info.focusDistanceCalibration for details.</units>
          <range>&amp;gt;=0</range>
          <details>If variable focus not supported, can still report
          fixed depth of field range</details>
          <tag id="BC" />
        </entry>
        <clone entry="android.lens.opticalStabilizationMode"
        kind="controls">
          <tag id="V1" />
        </clone>
        <entry name="state" type="byte" visibility="public" enum="true">
          <enum>
            <value>STATIONARY
              <notes>
              The lens parameters (android.lens.focalLength, android.lens.focusDistance,
              android.lens.filterDensity and android.lens.aperture) are not changing.
              </notes>
            </value>
            <value>MOVING
              <notes>
              Any of the lens parameters (android.lens.focalLength, android.lens.focusDistance,
              android.lens.filterDensity or android.lens.aperture) is changing.
              </notes>
            </value>
          </enum>
          <description>Current lens status.</description>
          <details>
          For lens parameters android.lens.focalLength, android.lens.focusDistance,
          android.lens.filterDensity and android.lens.aperture, when changes are requested,
          they may take several frames to reach the requested values. This state indicates
          the current status of the lens parameters.

          When the state is STATIONARY, the lens parameters are not changing. This could be
          either because the parameters are all fixed, or because the lens has had enough
          time to reach the most recently-requested values.
          If all these lens parameters are not changable for a camera device, as listed below:

          * Fixed focus (`android.lens.info.minimumFocusDistance == 0`), which means
          android.lens.focusDistance parameter will always be 0.
          * Fixed focal length (android.lens.info.availableFocalLengths contains single value),
          which means the optical zoom is not supported.
          * No ND filter (android.lens.info.availableFilterDensities contains only 0).
          * Fixed aperture (android.lens.info.availableApertures contains single value).

          Then this state will always be STATIONARY.

          When the state is MOVING, it indicates that at least one of the lens parameters
          is changing.
          </details>
          <tag id="V1" />
        </entry>
      </dynamic>
    </section>
    <section name="noiseReduction">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>No noise reduction is applied</notes></value>
            <value>FAST
            <notes>Must not slow down frame rate relative to sensor
            output</notes></value>
            <value>HIGH_QUALITY
            <notes>May slow down frame rate to provide highest
            quality</notes></value>
          </enum>
          <description>Mode of operation for the noise reduction
          algorithm</description>
          <details>Noise filtering control. OFF means no noise reduction
          will be applied by the camera device.

          This must be set to a valid mode in
          android.noiseReduction.availableNoiseReductionModes.

          FAST/HIGH_QUALITY both mean camera device determined noise filtering
          will be applied. HIGH_QUALITY mode indicates that the camera device
          will use the highest-quality noise filtering algorithms,
          even if it slows down capture rate. FAST means the camera device should not
          slow down capture rate when applying noise filtering.</details>
          <tag id="V1" />
        </entry>
        <entry name="strength" type="byte">
          <description>Control the amount of noise reduction
          applied to the images</description>
          <units>1-10; 10 is max noise reduction</units>
          <range>1 - 10</range>
        </entry>
      </controls>
      <static>
        <entry name="availableNoiseReductionModes" type="byte" visibility="public"
        type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>
          The set of noise reduction modes supported by this camera device.
          </description>
          <details>
          This tag lists the valid modes for android.noiseReduction.mode.

          Full-capability camera devices must laways support OFF and FAST.
          </details>
          <tag id="V1" />
        </entry>
      </static>
      <dynamic>
        <clone entry="android.noiseReduction.mode" kind="controls">
          <tag id="V1" />
        </clone>
      </dynamic>
    </section>
    <section name="quirks">
      <static>
        <entry name="meteringCropRegion" type="byte" visibility="system" optional="true">
          <description>If set to 1, the camera service does not
          scale 'normalized' coordinates with respect to the crop
          region. This applies to metering input (a{e,f,wb}Region
          and output (face rectangles).</description>
          <range>**Deprecated**. Do not use.</range>
          <details>Normalized coordinates refer to those in the
          (-1000,1000) range mentioned in the
          android.hardware.Camera API.

          HAL implementations should instead always use and emit
          sensor array-relative coordinates for all region data. Does
          not need to be listed in static metadata. Support will be
          removed in future versions of camera service.</details>
        </entry>
        <entry name="triggerAfWithAuto" type="byte" visibility="system" optional="true">
          <description>If set to 1, then the camera service always
          switches to FOCUS_MODE_AUTO before issuing a AF
          trigger.</description>
          <range>**Deprecated**. Do not use.</range>
          <details>HAL implementations should implement AF trigger
          modes for AUTO, MACRO, CONTINUOUS_FOCUS, and
          CONTINUOUS_PICTURE modes instead of using this flag. Does
          not need to be listed in static metadata. Support will be
          removed in future versions of camera service</details>
        </entry>
        <entry name="useZslFormat" type="byte" visibility="system" optional="true">
          <description>If set to 1, the camera service uses
          CAMERA2_PIXEL_FORMAT_ZSL instead of
          HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED for the zero
          shutter lag stream</description>
          <range>**Deprecated**. Do not use.</range>
          <details>HAL implementations should use gralloc usage flags
          to determine that a stream will be used for
          zero-shutter-lag, instead of relying on an explicit
          format setting. Does not need to be listed in static
          metadata. Support will be removed in future versions of
          camera service.</details>
        </entry>
        <entry name="usePartialResult" type="byte" visibility="hidden" optional="true">
          <description>
          If set to 1, the HAL will always split result
          metadata for a single capture into multiple buffers,
          returned using multiple process_capture_result calls.
          </description>
          <range>**Deprecated**. Do not use.</range>
          <details>
          Does not need to be listed in static
          metadata. Support for partial results will be reworked in
          future versions of camera service. This quirk will stop
          working at that point; DO NOT USE without careful
          consideration of future support.
          </details>
          <hal_details>
          Refer to `camera3_capture_result::partial_result`
          for information on how to implement partial results.
          </hal_details>
        </entry>
      </static>
      <dynamic>
        <entry name="partialResult" type="byte" visibility="hidden" optional="true" enum="true" typedef="boolean">
          <enum>
            <value>FINAL
            <notes>The last or only metadata result buffer
            for this capture.</notes>
            </value>
            <value>PARTIAL
            <notes>A partial buffer of result metadata for this
            capture. More result buffers for this capture will be sent
            by the camera device, the last of which will be marked
            FINAL.</notes>
            </value>
          </enum>
          <description>
          Whether a result given to the framework is the
          final one for the capture, or only a partial that contains a
          subset of the full set of dynamic metadata
          values.</description>
          <range>**Deprecated**. Do not use. Optional. Default value is FINAL.</range>
          <details>
          The entries in the result metadata buffers for a
          single capture may not overlap, except for this entry. The
          FINAL buffers must retain FIFO ordering relative to the
          requests that generate them, so the FINAL buffer for frame 3 must
          always be sent to the framework after the FINAL buffer for frame 2, and
          before the FINAL buffer for frame 4. PARTIAL buffers may be returned
          in any order relative to other frames, but all PARTIAL buffers for a given
          capture must arrive before the FINAL buffer for that capture. This entry may
          only be used by the camera device if quirks.usePartialResult is set to 1.
          </details>
          <hal_details>
          Refer to `camera3_capture_result::partial_result`
          for information on how to implement partial results.
          </hal_details>
        </entry>
      </dynamic>
    </section>
    <section name="request">
      <controls>
        <entry name="frameCount" type="int32" visibility="system">
          <description>A frame counter set by the framework. Must
          be maintained unchanged in output frame. This value monotonically
          increases with every new result (that is, each new result has a unique
          frameCount value).
          </description>
          <units>incrementing integer</units>
          <range>**Deprecated**. Do not use. Any int.</range>
        </entry>
        <entry name="id" type="int32" visibility="hidden">
          <description>An application-specified ID for the current
          request. Must be maintained unchanged in output
          frame</description>
          <units>arbitrary integer assigned by application</units>
          <range>Any int</range>
          <tag id="V1" />
        </entry>
        <entry name="inputStreams" type="int32" visibility="system"
               container="array">
          <array>
            <size>n</size>
          </array>
          <description>List which camera reprocess stream is used
          for the source of reprocessing data.</description>
          <units>List of camera reprocess stream IDs</units>
          <range>**Deprecated**. Do not use.

          Typically, only one entry allowed, must be a valid reprocess stream ID.
          </range>
          <details>Only meaningful when android.request.type ==
          REPROCESS. Ignored otherwise</details>
          <tag id="HAL2" />
        </entry>
        <entry name="metadataMode" type="byte" visibility="system"
               enum="true">
          <enum>
            <value>NONE
            <notes>No metadata should be produced on output, except
            for application-bound buffer data. If no
            application-bound streams exist, no frame should be
            placed in the output frame queue. If such streams
            exist, a frame should be placed on the output queue
            with null metadata but with the necessary output buffer
            information. Timestamp information should still be
            included with any output stream buffers</notes></value>
            <value>FULL
            <notes>All metadata should be produced. Statistics will
            only be produced if they are separately
            enabled</notes></value>
          </enum>
          <description>How much metadata to produce on
          output</description>
        </entry>
        <entry name="outputStreams" type="int32" visibility="system"
               container="array">
          <array>
            <size>n</size>
          </array>
          <description>Lists which camera output streams image data
          from this capture must be sent to</description>
          <units>List of camera stream IDs</units>
          <range>**Deprecated**. Do not use. List must only include streams that have been
          created</range>
          <details>If no output streams are listed, then the image
          data should simply be discarded. The image data must
          still be captured for metadata and statistics production,
          and the lens and flash must operate as requested.</details>
          <tag id="HAL2" />
        </entry>
        <entry name="type" type="byte" visibility="system" enum="true">
          <enum>
            <value>CAPTURE
            <notes>Capture a new image from the imaging hardware,
            and process it according to the
            settings</notes></value>
            <value>REPROCESS
            <notes>Process previously captured data; the
            android.request.inputStreams parameter determines the
            source reprocessing stream. TODO: Mark dynamic metadata
            needed for reprocessing with [RP]</notes></value>
          </enum>
          <description>The type of the request; either CAPTURE or
          REPROCESS. For HAL3, this tag is redundant.
          </description>
          <range>**Deprecated**. Do not use.</range>
          <tag id="HAL2" />
        </entry>
      </controls>
      <static>
        <entry name="maxNumOutputStreams" type="int32" visibility="public"
        container="array">
          <array>
            <size>3</size>
          </array>
          <description>The maximum numbers of different types of output streams
          that can be configured and used simultaneously by a camera device.
          </description>
          <range>
          For processed (and stalling) format streams, &amp;gt;= 1.

          For Raw format (either stalling or non-stalling) streams, &amp;gt;= 0.

          For processed (but not stalling) format streams, &amp;gt;= 3
          for FULL mode devices (`android.info.supportedHardwareLevel == FULL`);
          &amp;gt;= 2 for LIMITED mode devices (`android.info.supportedHardwareLevel == LIMITED`).
          </range>
          <details>
          This is a 3 element tuple that contains the max number of output simultaneous
          streams for raw sensor, processed (but not stalling), and processed (and stalling)
          formats respectively. For example, assuming that JPEG is typically a processed and
          stalling stream, if max raw sensor format output stream number is 1, max YUV streams
          number is 3, and max JPEG stream number is 2, then this tuple should be `(1, 3, 2)`.

          This lists the upper bound of the number of output streams supported by
          the camera device. Using more streams simultaneously may require more hardware and
          CPU resources that will consume more power. The image format for a output stream can
          be any supported format provided by android.scaler.availableStreamConfigurations.
          The formats defined in android.scaler.availableStreamConfigurations can be catergorized
          into the 3 stream types as below:

          * Processed (but stalling): any non-RAW format with a stallDurations &amp;gt; 0.
          Typically JPEG format (ImageFormat#JPEG).
          * Raw formats: ImageFormat#RAW_SENSOR and ImageFormat#RAW_OPAQUE.
          * Processed (but not-stalling): any non-RAW format without a stall duration.
          Typically ImageFormat#YUV_420_888, ImageFormat#NV21, ImageFormat#YV12.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="maxNumReprocessStreams" type="int32" visibility="system"
        container="array">
          <array>
            <size>1</size>
          </array>
          <description>How many reprocessing streams of any type
          can be allocated at the same time.</description>
          <range>&amp;gt;= 0</range>
          <details>
          **Deprecated**. Only used by HAL2.x.

          When set to 0, it means no reprocess stream is supported.
          </details>
          <tag id="HAL2" />
        </entry>
        <entry name="maxNumInputStreams" type="int32" visibility="public">
          <description>
          The maximum numbers of any type of input streams
          that can be configured and used simultaneously by a camera device.
          </description>
          <range>
          &amp;gt;= 0 for LIMITED mode device (`android.info.supportedHardwareLevel == LIMITED`).
          &amp;gt;= 1 for FULL mode device (`android.info.supportedHardwareLevel == FULL`).
          </range>
          <details>When set to 0, it means no input stream is supported.

          The image format for a input stream can be any supported
          format provided by
          android.scaler.availableInputOutputFormatsMap. When using an
          input stream, there must be at least one output stream
          configured to to receive the reprocessed images.

          For example, for Zero Shutter Lag (ZSL) still capture use case, the input
          stream image format will be RAW_OPAQUE, the associated output stream image format
          should be JPEG.
          </details>
        </entry>
      </static>
      <dynamic>
        <entry name="frameCount" type="int32" visibility="public">
          <description>A frame counter set by the framework. This value monotonically
          increases with every new result (that is, each new result has a unique
          frameCount value).</description>
          <units>count of frames</units>
          <range>&amp;gt; 0</range>
          <details>Reset on release()</details>
        </entry>
        <clone entry="android.request.id" kind="controls"></clone>
        <clone entry="android.request.metadataMode"
        kind="controls"></clone>
        <clone entry="android.request.outputStreams"
        kind="controls"></clone>
        <entry name="pipelineDepth" type="byte" visibility="public">
          <description>Specifies the number of pipeline stages the frame went
          through from when it was exposed to when the final completed result
          was available to the framework.</description>
          <range>&amp;lt;= android.request.pipelineMaxDepth</range>
          <details>Depending on what settings are used in the request, and
          what streams are configured, the data may undergo less processing,
          and some pipeline stages skipped.

          See android.request.pipelineMaxDepth for more details.
          </details>
          <hal_details>
          This value must always represent the accurate count of how many
          pipeline stages were actually used.
          </hal_details>
        </entry>
      </dynamic>
      <static>
        <entry name="pipelineMaxDepth" type="byte" visibility="public">
          <description>Specifies the number of maximum pipeline stages a frame
          has to go through from when it's exposed to when it's available
          to the framework.</description>
          <details>A typical minimum value for this is 2 (one stage to expose,
          one stage to readout) from the sensor. The ISP then usually adds
          its own stages to do custom HW processing. Further stages may be
          added by SW processing.

          Depending on what settings are used (e.g. YUV, JPEG) and what
          processing is enabled (e.g. face detection), the actual pipeline
          depth (specified by android.request.pipelineDepth) may be less than
          the max pipeline depth.

          A pipeline depth of X stages is equivalent to a pipeline latency of
          X frame intervals.

          This value will be 8 or less.
          </details>
          <hal_details>
          This value should be 4 or less.
          </hal_details>
        </entry>
        <entry name="partialResultCount" type="int32" visibility="public">
          <description>Optional. Defaults to 1. Defines how many sub-components
          a result will be composed of.
          </description>
          <range>&amp;gt;= 1</range>
          <details>In order to combat the pipeline latency, partial results
          may be delivered to the application layer from the camera device as
          soon as they are available.

          A value of 1 means that partial results are not supported.

          A typical use case for this might be: after requesting an AF lock the
          new AF state might be available 50% of the way through the pipeline.
          The camera device could then immediately dispatch this state via a
          partial result to the framework/application layer, and the rest of
          the metadata via later partial results.
          </details>
        </entry>
        <entry name="availableCapabilities" type="byte" visibility="public"
          enum="true">
          <enum>
            <value>BACKWARD_COMPATIBLE
              <notes>The minimal set of capabilities that every camera
                device (regardless of android.info.supportedHardwareLevel)
                will support.

                The full set of features supported by this capability makes
                the camera2 api backwards compatible with the camera1
                (android.hardware.Camera) API.

                TODO: @hide this. Doesn't really mean anything except
                act as a catch-all for all the 'base' functionality.
              </notes>
            </value>
            <value>OPTIONAL
              <notes>This is a catch-all capability to include all other
              tags or functionality not encapsulated by one of the other
              capabilities.

              A typical example is all tags marked 'optional'.

              TODO: @hide. We may not need this if we @hide all the optional
              tags not belonging to a capability.
              </notes>
            </value>
            <value>MANUAL_SENSOR
              <notes>
              The camera device can be manually controlled (3A algorithms such
              as auto exposure, and auto focus can be
              bypassed), this includes but is not limited to:

              * Manual exposure control
                  * android.sensor.exposureTime
                  * android.sensor.info.exposureTimeRange
              * Manual sensitivity control
                  * android.sensor.sensitivity
                  * android.sensor.info.sensitivityRange
                  * android.sensor.baseGainFactor
              * Manual lens control
                  * android.lens.*
              * Manual flash control
                  * android.flash.*
              * Manual black level locking
                  * android.blackLevel.lock

              If any of the above 3A algorithms are enabled, then the camera
              device will accurately report the values applied by 3A in the
              result.
              </notes>
            </value>
            <value optional="true">GCAM
              <notes>
              TODO: This should be @hide

              * Manual tonemap control
                    * android.tonemap.curveBlue
                    * android.tonemap.curveGreen
                    * android.tonemap.curveRed
                    * android.tonemap.mode
                    * android.tonemap.maxCurvePoints
              * Manual white balance control
                  * android.colorCorrection.transform
                  * android.colorCorrection.gains
              * Lens shading map information
                    * android.statistics.lensShadingMap
                    * android.lens.info.shadingMapSize

              If auto white balance is enabled, then the camera device
              will accurately report the values applied by AWB in the result.

              The camera device will also support everything in MANUAL_SENSOR
              except manual lens control and manual flash control.
              </notes>
            </value>
            <value>ZSL
              <notes>
              The camera device supports the Zero Shutter Lag use case.

              * At least one input stream can be used.
              * RAW_OPAQUE is supported as an output/input format
              * Using RAW_OPAQUE does not cause a frame rate drop
                relative to the sensor's maximum capture rate (at that
                resolution).
              * RAW_OPAQUE will be reprocessable into both YUV_420_888
                and JPEG formats.
              * The maximum available resolution for RAW_OPAQUE streams
                (both input/output) will match the maximum available
                resolution of JPEG streams.
              </notes>
            </value>
            <value optional="true">DNG
              <notes>
              The camera device supports outputting RAW buffers that can be
              saved offline into a DNG format. It can reprocess DNG
              files (produced from the same camera device) back into YUV.

              * At least one input stream can be used.
              * RAW16 is supported as output/input format.
              * RAW16 is reprocessable into both YUV_420_888 and JPEG
                formats.
              * The maximum available resolution for RAW16 streams (both
                input/output) will match the value in
                android.sensor.info.pixelArraySize.
              * All DNG-related optional metadata entries are provided
                by the camera device.
              </notes>
            </value>
          </enum>
          <description>List of capabilities that the camera device
          advertises as fully supporting.</description>
          <details>
          A capability is a contract that the camera device makes in order
          to be able to satisfy one or more use cases.

          Listing a capability guarantees that the whole set of features
          required to support a common use will all be available.

          Using a subset of the functionality provided by an unsupported
          capability may be possible on a specific camera device implementation;
          to do this query each of android.request.availableRequestKeys,
          android.request.availableResultKeys,
          android.request.availableCharacteristicsKeys.

          XX: Maybe these should go into android.info.supportedHardwareLevel
          as a table instead?

          The following capabilities are guaranteed to be available on
          android.info.supportedHardwareLevel `==` FULL devices:

          * MANUAL_SENSOR
          * ZSL

          Other capabilities may be available on either FULL or LIMITED
          devices, but the app. should query this field to be sure.
          </details>
          <hal_details>
          Additional constraint details per-capability will be available
          in the Compatibility Test Suite.

          BACKWARD_COMPATIBLE capability requirements are not explicitly listed.
          Instead refer to "BC" tags and the camera CTS tests in the
          android.hardware.cts package.

          Listed controls that can be either request or result (e.g.
          android.sensor.exposureTime) must be available both in the
          request and the result in order to be considered to be
          capability-compliant.

          For example, if the HAL claims to support MANUAL control,
          then exposure time must be configurable via the request _and_
          the actual exposure applied must be available via
          the result.
          </hal_details>
        </entry>
        <entry name="availableRequestKeys" type="int32" visibility="hidden"
          container="array">
          <array>
            <size>n</size>
          </array>
          <description>A list of all keys that the camera device has available
          to use with CaptureRequest.</description>

          <details>Attempting to set a key into a CaptureRequest that is not
          listed here will result in an invalid request and will be rejected
          by the camera device.

          This field can be used to query the feature set of a camera device
          at a more granular level than capabilities. This is especially
          important for optional keys that are not listed under any capability
          in android.request.availableCapabilities.

          TODO: This should be used by #getAvailableCaptureRequestKeys.
          </details>
          <hal_details>
          Vendor tags must not be listed here. Use the vendor tag metadata
          extensions C api instead (refer to camera3.h for more details).

          Setting/getting vendor tags will be checked against the metadata
          vendor extensions API and not against this field.

          The HAL must not consume any request tags that are not listed either
          here or in the vendor tag list.

          The public camera2 API will always make the vendor tags visible
          via CameraCharacteristics#getAvailableCaptureRequestKeys.
          </hal_details>
        </entry>
        <entry name="availableResultKeys" type="int32" visibility="hidden"
          container="array">
          <array>
            <size>n</size>
          </array>
          <description>A list of all keys that the camera device has available
          to use with CaptureResult.</description>

          <details>Attempting to get a key from a CaptureResult that is not
          listed here will always return a `null` value. Getting a key from
          a CaptureResult that is listed here must never return a `null`
          value.

          The following keys may return `null` unless they are enabled:

          * android.statistics.lensShadingMap (non-null iff android.statistics.lensShadingMapMode == ON)

          (Those sometimes-null keys should nevertheless be listed here
          if they are available.)

          This field can be used to query the feature set of a camera device
          at a more granular level than capabilities. This is especially
          important for optional keys that are not listed under any capability
          in android.request.availableCapabilities.

          TODO: This should be used by #getAvailableCaptureResultKeys.
          </details>
          <hal_details>
          Tags listed here must always have an entry in the result metadata,
          even if that size is 0 elements. Only array-type tags (e.g. lists,
          matrices, strings) are allowed to have 0 elements.

          Vendor tags must not be listed here. Use the vendor tag metadata
          extensions C api instead (refer to camera3.h for more details).

          Setting/getting vendor tags will be checked against the metadata
          vendor extensions API and not against this field.

          The HAL must not produce any result tags that are not listed either
          here or in the vendor tag list.

          The public camera2 API will always make the vendor tags visible
          via CameraCharacteristics#getAvailableCaptureResultKeys.
          </hal_details>
        </entry>
        <entry name="availableCharacteristicsKeys" type="int32" visibility="hidden"
          container="array">
          <array>
            <size>n</size>
          </array>
          <description>A list of all keys that the camera device has available
          to use with CameraCharacteristics.</description>
          <details>This entry follows the same rules as
          android.request.availableResultKeys (except that it applies for
          CameraCharacteristics instead of CaptureResult). See above for more
          details.

          TODO: This should be used by CameraCharacteristics#getKeys.
          </details>
          <hal_details>
          Tags listed here must always have an entry in the static info metadata,
          even if that size is 0 elements. Only array-type tags (e.g. lists,
          matrices, strings) are allowed to have 0 elements.

          Vendor tags must not be listed here. Use the vendor tag metadata
          extensions C api instead (refer to camera3.h for more details).

          Setting/getting vendor tags will be checked against the metadata
          vendor extensions API and not against this field.

          The HAL must not have any tags in its static info that are not listed
          either here or in the vendor tag list.

          The public camera2 API will always make the vendor tags visible
          via CameraCharacteristics#getKeys.
          </hal_details>
        </entry>
      </static>
    </section>
    <section name="scaler">
      <controls>
        <entry name="cropRegion" type="int32" visibility="public"
               container="array" typedef="rectangle">
          <array>
            <size>4</size>
          </array>
          <description>(x, y, width, height).

          A rectangle with the top-level corner of (x,y) and size
          (width, height). The region of the sensor that is used for
          output. Each stream must use this rectangle to produce its
          output, cropping to a smaller region if necessary to
          maintain the stream's aspect ratio.

          HAL2.x uses only (x, y, width)</description>
          <units>(x,y) of top-left corner, width and height of region
          in pixels; (0,0) is top-left corner of
          android.sensor.activeArraySize</units>
          <details>
            Any additional per-stream cropping must be done to
            maximize the final pixel area of the stream.

            For example, if the crop region is set to a 4:3 aspect
            ratio, then 4:3 streams should use the exact crop
            region. 16:9 streams should further crop vertically
            (letterbox).

            Conversely, if the crop region is set to a 16:9, then 4:3
            outputs should crop horizontally (pillarbox), and 16:9
            streams should match exactly. These additional crops must
            be centered within the crop region.

            The output streams must maintain square pixels at all
            times, no matter what the relative aspect ratios of the
            crop region and the stream are.  Negative values for
            corner are allowed for raw output if full pixel array is
            larger than active pixel array. Width and height may be
            rounded to nearest larger supportable width, especially
            for raw output, where only a few fixed scales may be
            possible. The width and height of the crop region cannot
            be set to be smaller than floor( activeArraySize.width /
            android.scaler.availableMaxDigitalZoom ) and floor(
            activeArraySize.height /
            android.scaler.availableMaxDigitalZoom), respectively.
          </details>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <entry name="availableFormats" type="int32"
        visibility="public" enum="true"
        container="array" typedef="imageFormat">
          <array>
            <size>n</size>
          </array>
          <enum>
            <value optional="true" id="0x20">RAW16
              <notes>
              RAW16 is a standard, cross-platform format for raw image
              buffers with 16-bit pixels. Buffers of this format are typically
              expected to have a Bayer Color Filter Array (CFA) layout, which
              is given in android.sensor.info.colorFilterArrangement. Sensors
              with CFAs that are not representable by a format in
              android.sensor.info.colorFilterArrangement should not use this
              format.

              Buffers of this format will also follow the constraints given for
              RAW_OPAQUE buffers, but with relaxed performance constraints.

              See android.scaler.availableInputOutputFormatsMap for
              the full set of performance guarantees.
              </notes>
            </value>
            <value optional="true" id="0x24">RAW_OPAQUE
              <notes>
              RAW_OPAQUE is a format for raw image buffers coming from an
              image sensor. The actual structure of buffers of this format is
              platform-specific, but must follow several constraints:

              1. No image post-processing operations may have been applied to
              buffers of this type. These buffers contain raw image data coming
              directly from the image sensor.
              1. If a buffer of this format is passed to the camera device for
              reprocessing, the resulting images will be identical to the images
              produced if the buffer had come directly from the sensor and was
              processed with the same settings.

              The intended use for this format is to allow access to the native
              raw format buffers coming directly from the camera sensor without
              any additional conversions or decrease in framerate.

              See android.scaler.availableInputOutputFormatsMap for the full set of
              performance guarantees.
              </notes>
            </value>
            <value optional="true" id="0x32315659">YV12
              <notes>YCrCb 4:2:0 Planar</notes>
            </value>
            <value optional="true" id="0x11">YCrCb_420_SP
              <notes>NV21</notes>
            </value>
            <value id="0x22">IMPLEMENTATION_DEFINED
              <notes>System internal format, not application-accessible</notes>
            </value>
            <value id="0x23">YCbCr_420_888
              <notes>Flexible YUV420 Format</notes>
            </value>
            <value id="0x21">BLOB
              <notes>JPEG format</notes>
            </value>
          </enum>
          <description>The list of image formats that are supported by this
          camera device for output streams.</description>
          <range>**Deprecated**. Do not use.</range>
          <details>
          All camera devices will support JPEG and YUV_420_888 formats.

          When set to YUV_420_888, application can access the YUV420 data directly.
          </details>
          <hal_details>
          These format values are from HAL_PIXEL_FORMAT_* in
          system/core/include/system/graphics.h.

          When IMPLEMENTATION_DEFINED is used, the platform
          gralloc module will select a format based on the usage flags provided
          by the camera HAL device and the other endpoint of the stream. It is
          usually used by preview and recording streams, where the application doesn't
          need access the image data.

          YCbCr_420_888 format must be supported by the HAL. When an image stream
          needs CPU/application direct access, this format will be used.

          The BLOB format must be supported by the HAL. This is used for the JPEG stream.

          A RAW_OPAQUE buffer should contain only pixel data. It is strongly
          recommended that any information used by the camera device when
          processing images is fully expressed by the result metadata
          for that image buffer.
          </hal_details>
          <tag id="BC" />
        </entry>
        <entry name="availableJpegMinDurations" type="int64" visibility="public"
        container="array">
          <array>
            <size>n</size>
          </array>
          <description>The minimum frame duration that is supported
          for each resolution in android.scaler.availableJpegSizes.
          </description>
          <units>ns</units>
          <range>**Deprecated**. Do not use. TODO: Remove property.</range>
          <details>
          This corresponds to the minimum steady-state frame duration when only
          that JPEG stream is active and captured in a burst, with all
          processing (typically in android.*.mode) set to FAST.

          When multiple streams are configured, the minimum
          frame duration will be &amp;gt;= max(individual stream min
          durations)</details>
          <tag id="BC" />
        </entry>
        <entry name="availableJpegSizes" type="int32" visibility="public"
        container="array" typedef="size">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>The JPEG resolutions that are supported by this camera device.</description>
          <range>**Deprecated**. Do not use. TODO: Remove property.</range>
          <details>
          The resolutions are listed as `(width, height)` pairs. All camera devices will support
          sensor maximum resolution (defined by android.sensor.info.activeArraySize).
          </details>
          <hal_details>
          The HAL must include sensor maximum resolution
          (defined by android.sensor.info.activeArraySize),
          and should include half/quarter of sensor maximum resolution.
          </hal_details>
          <tag id="BC" />
        </entry>
        <entry name="availableMaxDigitalZoom" type="float" visibility="public">
          <description>The maximum ratio between active area width
          and crop region width, or between active area height and
          crop region height, if the crop region height is larger
          than width</description>
          <range>&amp;gt;=1</range>
          <tag id="BC" />
        </entry>
        <entry name="availableProcessedMinDurations" type="int64" visibility="public"
        container="array">
          <array>
            <size>n</size>
          </array>
          <description>For each available processed output size (defined in
          android.scaler.availableProcessedSizes), this property lists the
          minimum supportable frame duration for that size.
          </description>
          <units>ns</units>
          <range>**Deprecated**. Do not use. TODO: Remove property.</range>
          <details>
          This should correspond to the frame duration when only that processed
          stream is active, with all processing (typically in android.*.mode)
          set to FAST.

          When multiple streams are configured, the minimum frame duration will
          be &amp;gt;= max(individual stream min durations).
          </details>
          <tag id="BC" />
        </entry>
        <entry name="availableProcessedSizes" type="int32" visibility="public"
        container="array" typedef="size">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>The resolutions available for use with
          processed output streams, such as YV12, NV12, and
          platform opaque YUV/RGB streams to the GPU or video
          encoders.</description>
          <range>**Deprecated**. Do not use. TODO: Remove property.</range>
          <details>
          The resolutions are listed as `(width, height)` pairs.

          For a given use case, the actual maximum supported resolution
          may be lower than what is listed here, depending on the destination
          Surface for the image data. For example, for recording video,
          the video encoder chosen may have a maximum size limit (e.g. 1080p)
          smaller than what the camera (e.g. maximum resolution is 3264x2448)
          can provide.

          Please reference the documentation for the image data destination to
          check if it limits the maximum size for image data.
          </details>
          <hal_details>
          For FULL capability devices (`android.info.supportedHardwareLevel == FULL`),
          the HAL must include all JPEG sizes listed in android.scaler.availableJpegSizes
          and each below resolution if it is smaller than or equal to the sensor
          maximum resolution (if they are not listed in JPEG sizes already):

          * 240p (320 x 240)
          * 480p (640 x 480)
          * 720p (1280 x 720)
          * 1080p (1920 x 1080)

          For LIMITED capability devices (`android.info.supportedHardwareLevel == LIMITED`),
          the HAL only has to list up to the maximum video size supported by the devices.
          </hal_details>
          <tag id="BC" />
        </entry>
        <entry name="availableRawMinDurations" type="int64"
        container="array">
          <array>
            <size>n</size>
          </array>
          <description>
          For each available raw output size (defined in
          android.scaler.availableRawSizes), this property lists the minimum
          supportable frame duration for that size.
          </description>
          <units>ns</units>
          <range>**Deprecated**. Do not use. TODO: Remove property.</range>
          <details>
          Should correspond to the frame duration when only the raw stream is
          active.

          When multiple streams are configured, the minimum
          frame duration will be &amp;gt;= max(individual stream min
          durations)</details>
          <tag id="BC" />
        </entry>
        <entry name="availableRawSizes" type="int32"
        container="array" typedef="size">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>The resolutions available for use with raw
          sensor output streams, listed as width,
          height</description>
          <range>**Deprecated**. Do not use. TODO: Remove property.
          Must include: - sensor maximum resolution.</range>
        </entry>
      </static>
      <dynamic>
        <clone entry="android.scaler.cropRegion" kind="controls">
        </clone>
      </dynamic>
      <static>
        <entry name="availableInputOutputFormatsMap" type="int32"
        visibility="public"
        container="array" typedef="imageFormat">
          <array>
            <size>n</size>
          </array>
          <description>The mapping of image formats that are supported by this
          camera device for input streams, to their corresponding output formats.
          </description>
          <details>
          All camera devices with at least 1
          android.request.maxNumInputStreams will have at least one
          available input format.

          The camera device will support the following map of formats,
          if its dependent capability is supported:

            Input Format  | Output Format    | Capability
          :---------------|:-----------------|:----------
          RAW_OPAQUE      | JPEG             | ZSL
          RAW_OPAQUE      | YUV_420_888      | ZSL
          RAW_OPAQUE      | RAW16            | DNG
          RAW16           | YUV_420_888      | DNG
          RAW16           | JPEG             | DNG

          For ZSL-capable camera devices, using the RAW_OPAQUE format
          as either input or output will never hurt maximum frame rate (i.e.
          android.scaler.availableStallDurations will not have RAW_OPAQUE).

          Attempting to configure an input stream with output streams not
          listed as available in this map is not valid.

          TODO: Add java type mapping for this property.
          </details>
          <hal_details>
          For the formats, see `system/core/include/system/graphics.h` for a definition
          of the image format enumerations.

          This value is encoded as a variable-size array-of-arrays.
          The inner array always contains `[format, length, ...]` where
          `...` has `length` elements. An inner array is followed by another
          inner array if the total metadata entry size hasn't yet been exceeded.

          A code sample to read/write this encoding (with a device that
          supports reprocessing RAW_OPAQUE to RAW16, YUV_420_888, and JPEG,
          and reprocessing RAW16 to YUV_420_888 and JPEG):

              // reading
              int32_t* contents = &amp;entry.i32[0];
              for (size_t i = 0; i &lt; entry.count; ) {
                  int32_t format = contents[i++];
                  int32_t length = contents[i++];
                  int32_t output_formats[length];
                  memcpy(&amp;output_formats[0], &amp;contents[i],
                         length * sizeof(int32_t));
                  i += length;
              }

              // writing (static example, DNG+ZSL)
              int32_t[] contents = {
                RAW_OPAQUE, 3, RAW16, YUV_420_888, BLOB,
                RAW16, 2, YUV_420_888, BLOB,
              };
              update_camera_metadata_entry(metadata, index, &amp;contents[0],
                    sizeof(contents)/sizeof(contents[0]), &amp;updated_entry);

          If the HAL claims to support any of the capabilities listed in the
          above details, then it must also support all the input-output
          combinations listed for that capability. It can optionally support
          additional formats if it so chooses.

          Refer to android.scaler.availableFormats for the enum values
          which correspond to HAL_PIXEL_FORMAT_* in
          system/core/include/system/graphics.h.
          </hal_details>
        </entry>
        <entry name="availableStreamConfigurations" type="int32" visibility="public"
          enum="true" container="array">
          <array>
            <size>n</size>
            <size>4</size>
          </array>
          <enum>
            <value>OUTPUT</value>
            <value>INPUT</value>
          </enum>
          <description>The available stream configurations that this
          camera device supports
          (i.e. format, width, height, output/input stream).
          </description>
          <details>
          The configurations are listed as `(format, width, height, input?)`
          tuples.

          All camera devices will support sensor maximum resolution (defined by
          android.sensor.info.activeArraySize) for the JPEG format.

          For a given use case, the actual maximum supported resolution
          may be lower than what is listed here, depending on the destination
          Surface for the image data. For example, for recording video,
          the video encoder chosen may have a maximum size limit (e.g. 1080p)
          smaller than what the camera (e.g. maximum resolution is 3264x2448)
          can provide.

          Please reference the documentation for the image data destination to
          check if it limits the maximum size for image data.

          Not all output formats may be supported in a configuration with
          an input stream of a particular format. For more details, see
          android.scaler.availableInputOutputFormatsMap.

          The following table describes the minimum required output stream
          configurations based on the hardware level
          (android.info.supportedHardwareLevel):

          Format         | Size                                         | Hardware Level | Notes
          :-------------:|:--------------------------------------------:|:--------------:|:--------------:
          JPEG           | android.sensor.info.activeArraySize          | Any            |
          JPEG           | 1920x1080 (1080p)                            | Any            | if 1080p &lt;= activeArraySize
          JPEG           | 1280x720 (720)                               | Any            | if 720p &lt;= activeArraySize
          JPEG           | 640x480 (480p)                               | Any            | if 480p &lt;= activeArraySize
          JPEG           | 320x240 (240p)                               | Any            | if 240p &lt;= activeArraySize
          YUV_420_888    | all output sizes available for JPEG          | FULL           |
          YUV_420_888    | all output sizes available for JPEG, up to the maximum video size | LIMITED        |
          IMPLEMENTATION_DEFINED | same as YUV_420_888                  | Any            |

          Refer to android.request.availableCapabilities for additional
          mandatory stream configurations on a per-capability basis.
          </details>
          <hal_details>
          It is recommended (but not mandatory) to also include half/quarter
          of sensor maximum resolution for JPEG formats (regardless of hardware
          level).

          (The following is a rewording of the above required table):

          The HAL must include sensor maximum resolution (defined by
          android.sensor.info.activeArraySize).

          For FULL capability devices (`android.info.supportedHardwareLevel == FULL`),
          the HAL must include all YUV_420_888 sizes that have JPEG sizes listed
          here as output streams.

          It must also include each below resolution if it is smaller than or
          equal to the sensor maximum resolution (for both YUV_420_888 and JPEG
          formats), as output streams:

          * 240p (320 x 240)
          * 480p (640 x 480)
          * 720p (1280 x 720)
          * 1080p (1920 x 1080)

          For LIMITED capability devices
          (`android.info.supportedHardwareLevel == LIMITED`),
          the HAL only has to list up to the maximum video size
          supported by the device.

          Regardless of hardware level, every output resolution available for
          YUV_420_888 must also be available for IMPLEMENTATION_DEFINED.

          This supercedes the following fields, which are now deprecated:

          * availableFormats
          * available[Processed,Raw,Jpeg]Sizes
          </hal_details>
        </entry>
        <entry name="availableMinFrameDurations" type="int64" visibility="public"
        container="array">
          <array>
            <size>4</size>
            <size>n</size>
          </array>
          <description>This lists the minimum frame duration for each
          format/size combination.
          </description>
          <units>(format, width, height, ns) x n</units>
          <details>
          This should correspond to the frame duration when only that
          stream is active, with all processing (typically in android.*.mode)
          set to either OFF or FAST.

          When multiple streams are used in a request, the minimum frame
          duration will be max(individual stream min durations).

          The minimum frame duration of a stream (of a particular format, size)
          is the same regardless of whether the stream is input or output.

          See android.sensor.frameDuration and
          android.scaler.availableStallDurations for more details about
          calculating the max frame rate.
          </details>
          <tag id="BC" />
        </entry>
        <entry name="availableStallDurations" type="int64" visibility="public"
        container="array">
          <array>
            <size>4</size>
            <size>n</size>
          </array>
          <description>This lists the maximum stall duration for each
          format/size combination.
          </description>
          <units>(format, width, height, ns) x n</units>
          <details>
          A stall duration is how much extra time would get added
          to the normal minimum frame duration for a repeating request
          that has streams with non-zero stall.

          For example, consider JPEG captures which have the following
          characteristics:

          * JPEG streams act like processed YUV streams in requests for which
          they are not included; in requests in which they are directly
          referenced, they act as JPEG streams. This is because supporting a
          JPEG stream requires the underlying YUV data to always be ready for
          use by a JPEG encoder, but the encoder will only be used (and impact
          frame duration) on requests that actually reference a JPEG stream.
          * The JPEG processor can run concurrently to the rest of the camera
          pipeline, but cannot process more than 1 capture at a time.

          In other words, using a repeating YUV request would result
          in a steady frame rate (let's say it's 30 FPS). If a single
          JPEG request is submitted periodically, the frame rate will stay
          at 30 FPS (as long as we wait for the previous JPEG to return each
          time). If we try to submit a repeating YUV + JPEG request, then
          the frame rate will drop from 30 FPS.

          In general, submitting a new request with a non-0 stall time
          stream will _not_ cause a frame rate drop unless there are still
          outstanding buffers for that stream from previous requests.

          Submitting a repeating request with streams (call this `S`)
          is the same as setting the minimum frame duration from
          the normal minimum frame duration corresponding to `S`, added with
          the maximum stall duration for `S`.

          If interleaving requests with and without a stall duration,
          a request will stall by the maximum of the remaining times
          for each can-stall stream with outstanding buffers.

          This means that a stalling request will not have an exposure start
          until the stall has completed.

          This should correspond to the stall duration when only that stream is
          active, with all processing (typically in android.*.mode) set to FAST
          or OFF. Setting any of the processing modes to HIGH_QUALITY
          effectively results in an indeterminate stall duration for all
          streams in a request (the regular stall calculation rules are
          ignored).

          The following formats may always have a stall duration:

          * JPEG
          * RAW16

          The following formats will never have a stall duration:

          * YUV_420_888
          * IMPLEMENTATION_DEFINED

          All other formats may or may not have an allowed stall duration on
          a per-capability basis; refer to android.request.availableCapabilities
          for more details.

          See android.sensor.frameDuration for more information about
          calculating the max frame rate (absent stalls).
          </details>
          <hal_details>
          If possible, it is recommended that all non-JPEG formats
          (such as RAW16) should not have a stall duration.
          </hal_details>
          <tag id="BC" />
        </entry>
      </static>
    </section>
    <section name="sensor">
      <controls>
        <entry name="exposureTime" type="int64" visibility="public">
          <description>Duration each pixel is exposed to
          light.</description>
          <units>nanoseconds</units>
          <range>android.sensor.info.exposureTimeRange</range>
          <details>If the sensor can't expose this exact duration, it should shorten the
          duration exposed to the nearest possible value (rather than expose longer).
          </details>
          <tag id="V1" />
        </entry>
        <entry name="frameDuration" type="int64" visibility="public">
          <description>Duration from start of frame exposure to
          start of next frame exposure.</description>
          <units>nanoseconds</units>
          <range>See android.sensor.info.maxFrameDuration,
          android.scaler.availableMinFrameDurations. The duration
          is capped to `max(duration, exposureTime + overhead)`.</range>
          <details>
          The maximum frame rate that can be supported by a camera subsystem is
          a function of many factors:

          * Requested resolutions of output image streams
          * Availability of binning / skipping modes on the imager
          * The bandwidth of the imager interface
          * The bandwidth of the various ISP processing blocks

          Since these factors can vary greatly between different ISPs and
          sensors, the camera abstraction tries to represent the bandwidth
          restrictions with as simple a model as possible.

          The model presented has the following characteristics:

          * The image sensor is always configured to output the smallest
          resolution possible given the application's requested output stream
          sizes.  The smallest resolution is defined as being at least as large
          as the largest requested output stream size; the camera pipeline must
          never digitally upsample sensor data when the crop region covers the
          whole sensor. In general, this means that if only small output stream
          resolutions are configured, the sensor can provide a higher frame
          rate.
          * Since any request may use any or all the currently configured
          output streams, the sensor and ISP must be configured to support
          scaling a single capture to all the streams at the same time.  This
          means the camera pipeline must be ready to produce the largest
          requested output size without any delay.  Therefore, the overall
          frame rate of a given configured stream set is governed only by the
          largest requested stream resolution.
          * Using more than one output stream in a request does not affect the
          frame duration.
          * Certain format-streams may need to do additional background processing
          before data is consumed/produced by that stream. These processors
          can run concurrently to the rest of the camera pipeline, but
          cannot process more than 1 capture at a time.

          The necessary information for the application, given the model above,
          is provided via the android.scaler.availableMinFrameDurations field.
          These are used to determine the maximum frame rate / minimum frame
          duration that is possible for a given stream configuration.

          Specifically, the application can use the following rules to
          determine the minimum frame duration it can request from the camera
          device:

          1. Let the set of currently configured input/output streams
          be called `S`.
          1. Find the minimum frame durations for each stream in `S`, by
          looking it up in android.scaler.availableMinFrameDurations (with
          its respective size/format). Let this set of frame durations be called
          `F`.
          1. For any given request `R`, the minimum frame duration allowed
          for `R` is the maximum out of all values in `F`. Let the streams
          used in `R` be called `S_r`.

          If none of the streams in `S_r` have a stall time (listed in
          android.scaler.availableStallDurations), then the frame duration in
          `F` determines the steady state frame rate that the application will
          get if it uses `R` as a repeating request. Let this special kind
          of request be called `Rsimple`.

          A repeating request `Rsimple` can be _occasionally_ interleaved
          by a single capture of a new request `Rstall` (which has at least
          one in-use stream with a non-0 stall time) and if `Rstall` has the
          same minimum frame duration this will not cause a frame rate loss
          if all buffers from the previous `Rstall` have already been
          delivered.

          For more details about stalling, see
          android.scaler.availableStallDurations.
          </details>
          <tag id="V1" />
          <tag id="BC" />
        </entry>
        <entry name="sensitivity" type="int32" visibility="public">
          <description>Gain applied to image data. Must be
          implemented through analog gain only if set to values
          below 'maximum analog sensitivity'.

          If the sensor can't apply this exact gain, it should lessen the
          gain to the nearest possible value (rather than gain more).
          </description>
          <units>ISO arithmetic units</units>
          <range>android.sensor.info.sensitivityRange</range>
          <details>ISO 12232:2006 REI method</details>
          <tag id="V1" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="activeArraySize" type="int32" visibility="public"
          type_notes="Four ints defining the active pixel rectangle"
          container="array"
          typedef="rectangle">
            <array>
              <size>4</size>
            </array>
            <description>Area of raw data which corresponds to only
            active pixels.</description>
            <range>This array contains `(xmin, ymin, width, height)`. The `(xmin, ymin)` must be
            &amp;gt;= `(0,0)`. The `(width, height)` must be &amp;lt;=
            `android.sensor.info.pixelArraySize`.
            </range>
            <details>It is smaller or equal to
            sensor full pixel array, which could include the black calibration pixels.</details>
            <tag id="DNG" />
          </entry>
          <entry name="sensitivityRange" type="int32" visibility="public"
          type_notes="Range of supported sensitivities"
          container="array">
            <array>
              <size>2</size>
            </array>
            <description>Range of valid sensitivities</description>
            <range>Min &lt;= 100, Max &amp;gt;= 1600</range>
            <tag id="BC" />
            <tag id="V1" />
          </entry>
          <entry name="colorFilterArrangement" type="byte" visibility="public" enum="true">
            <enum>
              <value>RGGB</value>
              <value>GRBG</value>
              <value>GBRG</value>
              <value>BGGR</value>
              <value>RGB
              <notes>Sensor is not Bayer; output has 3 16-bit
              values for each pixel, instead of just 1 16-bit value
              per pixel.</notes></value>
            </enum>
            <description>Arrangement of color filters on sensor;
            represents the colors in the top-left 2x2 section of
            the sensor, in reading order</description>
            <tag id="DNG" />
          </entry>
          <entry name="exposureTimeRange" type="int64" visibility="public"
          type_notes="nanoseconds" container="array">
            <array>
              <size>2</size>
            </array>
            <description>Range of valid exposure
            times used by android.sensor.exposureTime.</description>
            <range>Min &lt;= 100e3 (100 us). For FULL capability devices
            (android.info.supportedHardwareLevel == FULL), Max SHOULD be
            &amp;gt;= 1e9 (1sec), MUST be &amp;gt;= 100e6 (100ms)</range>
            <hal_details>For FULL capability devices (android.info.supportedHardwareLevel == FULL),
            The maximum of the range SHOULD be at least
            1 second (1e9), MUST be at least 100ms.</hal_details>
            <tag id="V1" />
          </entry>
          <entry name="maxFrameDuration" type="int64" visibility="public">
            <description>Maximum possible frame duration (minimum frame
            rate).</description>
            <units>nanoseconds</units>
            <range>For FULL capability devices
            (android.info.supportedHardwareLevel == FULL), Max SHOULD be
            &amp;gt;= 1e9 (1sec), MUST be &amp;gt;= 100e6 (100ms)
            </range>
            <details>The largest possible android.sensor.frameDuration
            that will be accepted by the camera device. Attempting to use
            frame durations beyond the maximum will result in the frame duration
            being clipped to the maximum. See that control
            for a full definition of frame durations.

            Refer to
            android.scaler.availableProcessedMinDurations,
            android.scaler.availableJpegMinDurations, and
            android.scaler.availableRawMinDurations for the minimum
            frame duration values.
            </details>
            <hal_details>
            For FULL capability devices (android.info.supportedHardwareLevel == FULL),
            The maximum of the range SHOULD be at least
            1 second (1e9), MUST be at least 100ms (100e6).

            android.sensor.info.maxFrameDuration must be greater or
            equal to the android.sensor.info.exposureTimeRange max
            value (since exposure time overrides frame duration).

            Available minimum frame durations for JPEG must be no greater
            than that of the YUV_420_888/IMPLEMENTATION_DEFINED
            minimum frame durations (for that respective size).

            Since JPEG processing is considered offline and can take longer than
            a single uncompressed capture, refer to
            android.scaler.availableStallDurations
            for details about encoding this scenario.
            </hal_details>
            <tag id="BC" />
            <tag id="V1" />
          </entry>
          <entry name="physicalSize" type="float" visibility="public"
          type_notes="width x height in millimeters"
          container="array">
            <array>
              <size>2</size>
            </array>
            <description>The physical dimensions of the full pixel
            array</description>
            <details>Needed for FOV calculation for old API</details>
            <tag id="V1" />
            <tag id="BC" />
          </entry>
          <entry name="pixelArraySize" type="int32" visibility="public"
          container="array" typedef="size">
            <array>
              <size>2</size>
            </array>
            <description>Dimensions of full pixel array, possibly
            including black calibration pixels.</description>
            <details>Maximum output resolution for raw format must
            match this in
            android.scaler.availableStreamConfigurations.</details>
            <tag id="DNG" />
            <tag id="BC" />
          </entry>
          <entry name="whiteLevel" type="int32" visibility="public">
            <description>
            Maximum raw value output by sensor.
            </description>
            <range>&amp;gt; 255 (8-bit output)</range>
            <details>
            This specifies the fully-saturated encoding level for the raw
            sample values from the sensor.  This is typically caused by the
            sensor becoming highly non-linear or clipping. The minimum for
            each channel is specified by the offset in the
            android.sensor.blackLevelPattern tag.

            The white level is typically determined either by sensor bit depth
            (8-14 bits is expected), or by the point where the sensor response
            becomes too non-linear to be useful.  The default value for this is
            maximum representable value for a 16-bit raw sample (2^16 - 1).
            </details>
            <hal_details>
            The full bit depth of the sensor must be available in the raw data,
            so the value for linear sensors should not be significantly lower
            than maximum raw value supported, i.e. 2^(sensor bits per pixel).
            </hal_details>
            <tag id="DNG" />
          </entry>
        </namespace>
        <entry name="referenceIlluminant1" type="byte" visibility="public" enum="true">
          <enum>
            <value id="1">DAYLIGHT</value>
            <value id="2">FLUORESCENT</value>
            <value id="3">TUNGSTEN
              <notes>Incandescent light</notes>
            </value>
            <value id="4">FLASH</value>
            <value id="9">FINE_WEATHER</value>
            <value id="10">CLOUDY_WEATHER</value>
            <value id="11">SHADE</value>
            <value id="12">DAYLIGHT_FLUORESCENT
              <notes>D 5700 - 7100K</notes>
            </value>
            <value id="13">DAY_WHITE_FLUORESCENT
              <notes>N 4600 - 5400K</notes>
            </value>
            <value id="14">COOL_WHITE_FLUORESCENT
              <notes>W 3900 - 4500K</notes>
            </value>
            <value id="15">WHITE_FLUORESCENT
              <notes>WW 3200 - 3700K</notes>
            </value>
            <value id="17">STANDARD_A</value>
            <value id="18">STANDARD_B</value>
            <value id="19">STANDARD_C</value>
            <value id="20">D55</value>
            <value id="21">D65</value>
            <value id="22">D75</value>
            <value id="23">D50</value>
            <value id="24">ISO_STUDIO_TUNGSTEN</value>
          </enum>
          <description>
          The standard reference illuminant used as the scene light source when
          calculating the android.sensor.colorTransform1,
          android.sensor.calibrationTransform1, and
          android.sensor.forwardMatrix1 matrices.
          </description>
          <details>
          The values in this tag correspond to the values defined for the
          EXIF LightSource tag. These illuminants are standard light sources
          that are often used calibrating camera devices.

          If this tag is present, then android.sensor.colorTransform1,
          android.sensor.calibrationTransform1, and
          android.sensor.forwardMatrix1 will also be present.

          Some devices may choose to provide a second set of calibration
          information for improved quality, including
          android.sensor.referenceIlluminant2 and its corresponding matrices.
          </details>
          <hal_details>
          The first reference illuminant (android.sensor.referenceIlluminant1)
          and corresponding matrices must be present to support DNG output.

          When producing raw images with a color profile that has only been
          calibrated against a single light source, it is valid to omit
          android.sensor.referenceIlluminant2 along with the
          android.sensor.colorTransform2, android.sensor.calibrationTransform2,
          and android.sensor.forwardMatrix2 matrices.

          If only android.sensor.referenceIlluminant1 is included, it should be
          chosen so that it is representative of typical scene lighting.  In
          general, D50 or DAYLIGHT will be chosen for this case.

          If both android.sensor.referenceIlluminant1 and
          android.sensor.referenceIlluminant2 are included, they should be
          chosen to represent the typical range of scene lighting conditions.
          In general, low color temperature illuminant such as Standard-A will
          be chosen for the first reference illuminant and a higher color
          temperature illuminant such as D65 will be chosen for the second
          reference illuminant.
          </hal_details>
          <tag id="DNG" />
        </entry>
        <entry name="referenceIlluminant2" type="byte" visibility="public">
          <description>
          The standard reference illuminant used as the scene light source when
          calculating the android.sensor.colorTransform2,
          android.sensor.calibrationTransform2, and
          android.sensor.forwardMatrix2 matrices.
          </description>
          <details>
          See android.sensor.referenceIlluminant1 for more details.
          Valid values for this are the same as those given for the first
          reference illuminant.

          If this tag is present, then android.sensor.colorTransform2,
          android.sensor.calibrationTransform2, and
          android.sensor.forwardMatrix2 will also be present.
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="calibrationTransform1" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A per-device calibration transform matrix that maps from the
          reference sensor colorspace to the actual device sensor colorspace.
          </description>
          <details>
          This matrix is used to correct for per-device variations in the
          sensor colorspace, and is used for processing raw buffer data.

          The matrix is expressed as a 3x3 matrix in row-major-order, and
          contains a per-device calibration transform that maps colors
          from reference sensor color space (i.e. the "golden module"
          colorspace) into this camera device's native sensor color
          space under the first reference illuminant
          (android.sensor.referenceIlluminant1).
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="calibrationTransform2" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A per-device calibration transform matrix that maps from the
          reference sensor colorspace to the actual device sensor colorspace
          (this is the colorspace of the raw buffer data).
          </description>
          <details>
          This matrix is used to correct for per-device variations in the
          sensor colorspace, and is used for processing raw buffer data.

          The matrix is expressed as a 3x3 matrix in row-major-order, and
          contains a per-device calibration transform that maps colors
          from reference sensor color space (i.e. the "golden module"
          colorspace) into this camera device's native sensor color
          space under the second reference illuminant
          (android.sensor.referenceIlluminant2).

          This matrix will only be present if the second reference
          illuminant is present.
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="colorTransform1" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A matrix that transforms color values from CIE XYZ color space to
          reference sensor color space.
          </description>
          <details>
          This matrix is used to convert from the standard CIE XYZ color
          space to the reference sensor colorspace, and is used when processing
          raw buffer data.

          The matrix is expressed as a 3x3 matrix in row-major-order, and
          contains a color transform matrix that maps colors from the CIE
          XYZ color space to the reference sensor color space (i.e. the
          "golden module" colorspace) under the first reference illuminant
          (android.sensor.referenceIlluminant1).

          The white points chosen in both the reference sensor color space
          and the CIE XYZ colorspace when calculating this transform will
          match the standard white point for the first reference illuminant
          (i.e. no chromatic adaptation will be applied by this transform).
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="colorTransform2" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A matrix that transforms color values from CIE XYZ color space to
          reference sensor color space.
          </description>
          <details>
          This matrix is used to convert from the standard CIE XYZ color
          space to the reference sensor colorspace, and is used when processing
          raw buffer data.

          The matrix is expressed as a 3x3 matrix in row-major-order, and
          contains a color transform matrix that maps colors from the CIE
          XYZ color space to the reference sensor color space (i.e. the
          "golden module" colorspace) under the second reference illuminant
          (android.sensor.referenceIlluminant2).

          The white points chosen in both the reference sensor color space
          and the CIE XYZ colorspace when calculating this transform will
          match the standard white point for the second reference illuminant
          (i.e. no chromatic adaptation will be applied by this transform).

          This matrix will only be present if the second reference
          illuminant is present.
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="forwardMatrix1" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A matrix that transforms white balanced camera colors from the reference
          sensor colorspace to the CIE XYZ colorspace with a D50 whitepoint.
          </description>
          <details>
          This matrix is used to convert to the standard CIE XYZ colorspace, and
          is used when processing raw buffer data.

          This matrix is expressed as a 3x3 matrix in row-major-order, and contains
          a color transform matrix that maps white balanced colors from the
          reference sensor color space to the CIE XYZ color space with a D50 white
          point.

          Under the first reference illuminant (android.sensor.referenceIlluminant1)
          this matrix is chosen so that the standard white point for this reference
          illuminant in the reference sensor colorspace is mapped to D50 in the
          CIE XYZ colorspace.
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="forwardMatrix2" type="rational"
        visibility="public" optional="true"
        type_notes="3x3 matrix in row-major-order" container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>
          A matrix that transforms white balanced camera colors from the reference
          sensor colorspace to the CIE XYZ colorspace with a D50 whitepoint.
          </description>
          <details>
          This matrix is used to convert to the standard CIE XYZ colorspace, and
          is used when processing raw buffer data.

          This matrix is expressed as a 3x3 matrix in row-major-order, and contains
          a color transform matrix that maps white balanced colors from the
          reference sensor color space to the CIE XYZ color space with a D50 white
          point.

          Under the second reference illuminant (android.sensor.referenceIlluminant2)
          this matrix is chosen so that the standard white point for this reference
          illuminant in the reference sensor colorspace is mapped to D50 in the
          CIE XYZ colorspace.

          This matrix will only be present if the second reference
          illuminant is present.
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="baseGainFactor" type="rational" visibility="public"
        optional="true">
          <description>Gain factor from electrons to raw units when
          ISO=100</description>
          <tag id="V1" />
          <tag id="FULL" />
        </entry>
        <entry name="blackLevelPattern" type="int32" visibility="public"
        optional="true" type_notes="2x2 raw count block" container="array">
          <array>
            <size>4</size>
          </array>
          <description>
          A fixed black level offset for each of the color filter arrangement
          (CFA) mosaic channels.
          </description>
          <range>&amp;gt;= 0 for each.</range>
          <details>
          This tag specifies the zero light value for each of the CFA mosaic
          channels in the camera sensor.  The maximal value output by the
          sensor is represented by the value in android.sensor.info.whiteLevel.

          The values are given in row-column scan order, with the first value
          corresponding to the element of the CFA in row=0, column=0.
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="maxAnalogSensitivity" type="int32" visibility="public"
        optional="true">
          <description>Maximum sensitivity that is implemented
          purely through analog gain.</description>
          <details>For android.sensor.sensitivity values less than or
          equal to this, all applied gain must be analog. For
          values above this, the gain applied can be a mix of analog and
          digital.</details>
          <tag id="V1" />
          <tag id="FULL" />
        </entry>
        <entry name="orientation" type="int32" visibility="public">
          <description>Clockwise angle through which the output
          image needs to be rotated to be upright on the device
          screen in its native orientation. Also defines the
          direction of rolling shutter readout, which is from top
          to bottom in the sensor's coordinate system</description>
          <units>degrees clockwise rotation, only multiples of
          90</units>
          <range>0,90,180,270</range>
          <tag id="BC" />
        </entry>
        <entry name="profileHueSatMapDimensions" type="int32"
        visibility="system" optional="true"
        type_notes="Number of samples for hue, saturation, and value"
        container="array">
          <array>
            <size>3</size>
          </array>
          <description>
          The number of input samples for each dimension of
          android.sensor.profileHueSatMap.
          </description>
          <range>
          Hue &amp;gt;= 1,
          Saturation &amp;gt;= 2,
          Value &amp;gt;= 1
          </range>
          <details>
          The number of input samples for the hue, saturation, and value
          dimension of android.sensor.profileHueSatMap. The order of the
          dimensions given is hue, saturation, value; where hue is the 0th
          element.
          </details>
          <tag id="DNG" />
        </entry>
      </static>
      <dynamic>
        <clone entry="android.sensor.exposureTime" kind="controls">
        </clone>
        <clone entry="android.sensor.frameDuration"
        kind="controls"></clone>
        <clone entry="android.sensor.sensitivity" kind="controls">
        </clone>
        <entry name="timestamp" type="int64" visibility="public">
          <description>Time at start of exposure of first
          row</description>
          <units>nanoseconds</units>
          <range>&amp;gt; 0</range>
          <details>Monotonic, should be synced to other timestamps in
          system</details>
          <tag id="BC" />
        </entry>
        <entry name="temperature" type="float" visibility="public"
        optional="true">
          <description>The temperature of the sensor, sampled at the time
          exposure began for this frame.

          The thermal diode being queried should be inside the sensor PCB, or
          somewhere close to it.
          </description>

          <units>celsius</units>
          <range>Optional. This value is missing if no temperature is available.</range>
          <tag id="FULL" />
        </entry>
        <entry name="neutralColorPoint" type="rational" visibility="public"
        optional="true" container="array">
          <array>
            <size>3</size>
          </array>
          <description>
          The estimated camera neutral color in the native sensor colorspace at
          the time of capture.
          </description>
          <details>
          This value gives the neutral color point encoded as an RGB value in the
          native sensor color space.  The neutral color point indicates the
          currently estimated white point of the scene illumination.  It can be
          used to interpolate between the provided color transforms when
          processing raw sensor data.

          The order of the values is R, G, B; where R is in the lowest index.
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="profileHueSatMap" type="float"
        visibility="system" optional="true"
        type_notes="Mapping for hue, saturation, and value"
        container="array">
          <array>
            <size>hue_samples</size>
            <size>saturation_samples</size>
            <size>value_samples</size>
            <size>3</size>
          </array>
          <description>
          A mapping containing a hue shift, saturation scale, and value scale
          for each pixel.
          </description>
          <units>
          Hue shift is given in degrees; saturation and value scale factors are
          unitless.
          </units>
          <details>
          hue_samples, saturation_samples, and value_samples are given in
          android.sensor.profileHueSatMapDimensions.

          Each entry of this map contains three floats corresponding to the
          hue shift, saturation scale, and value scale, respectively; where the
          hue shift has the lowest index. The map entries are stored in the tag
          in nested loop order, with the value divisions in the outer loop, the
          hue divisions in the middle loop, and the saturation divisions in the
          inner loop. All zero input saturation entries are required to have a
          value scale factor of 1.0.
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="profileToneCurve" type="float"
        visibility="system" optional="true"
        type_notes="Samples defining a spline for a tone-mapping curve"
        container="array">
          <array>
            <size>samples</size>
            <size>2</size>
          </array>
          <description>
          A list of x,y samples defining a tone-mapping curve for gamma adjustment.
          </description>
          <range>
          Each sample has an input range of `[0, 1]` and an output range of
          `[0, 1]`.  The first sample is required to be `(0, 0)`, and the last
          sample is required to be `(1, 1)`.
          </range>
          <details>
          This tag contains a default tone curve that can be applied while
          processing the image as a starting point for user adjustments.
          The curve is specified as a list of value pairs in linear gamma.
          The curve is interpolated using a cubic spline.
          </details>
          <tag id="DNG" />
        </entry>
        <entry name="greenSplit" type="float" visibility="public" optional="true">
          <description>
          The worst-case divergence between Bayer green channels.
          </description>
          <range>
          &amp;gt;= 0
          </range>
          <details>
          This value is an estimate of the worst case split between the
          Bayer green channels in the red and blue rows in the sensor color
          filter array.

          The green split is calculated as follows:

          1. A 5x5 pixel (or larger) window W within the active sensor array is
          chosen. The term 'pixel' here is taken to mean a group of 4 Bayer
          mosaic channels (R, Gr, Gb, B).  The location and size of the window
          chosen is implementation defined, and should be chosen to provide a
          green split estimate that is both representative of the entire image
          for this camera sensor, and can be calculated quickly.
          1. The arithmetic mean of the green channels from the red
          rows (mean_Gr) within W is computed.
          1. The arithmetic mean of the green channels from the blue
          rows (mean_Gb) within W is computed.
          1. The maximum ratio R of the two means is computed as follows:
          `R = max((mean_Gr + 1)/(mean_Gb + 1), (mean_Gb + 1)/(mean_Gr + 1))`

          The ratio R is the green split divergence reported for this property,
          which represents how much the green channels differ in the mosaic
          pattern.  This value is typically used to determine the treatment of
          the green mosaic channels when demosaicing.

          The green split value can be roughly interpreted as follows:

          * R &amp;lt; 1.03 is a negligible split (&amp;lt;3% divergence).
          * 1.20 &amp;lt;= R &amp;gt;= 1.03 will require some software
          correction to avoid demosaic errors (3-20% divergence).
          * R &amp;gt; 1.20 will require strong software correction to produce
          a usuable image (&amp;gt;20% divergence).
          </details>
          <hal_details>
          The green split given may be a static value based on prior
          characterization of the camera sensor using the green split
          calculation method given here over a large, representative, sample
          set of images.  Other methods of calculation that produce equivalent
          results, and can be interpreted in the same manner, may be used.
          </hal_details>
          <tag id="DNG" />
        </entry>
      </dynamic>
      <controls>
        <entry name="testPatternData" type="int32" visibility="public" optional="true" container="array">
          <array>
            <size>4</size>
          </array>
          <description>
            A pixel `[R, G_even, G_odd, B]` that supplies the test pattern
            when android.sensor.testPatternMode is SOLID_COLOR.
          </description>
          <range>Optional.
          Must be supported if android.sensor.availableTestPatternModes contains
          SOLID_COLOR.</range>
          <details>
          Each color channel is treated as an unsigned 32-bit integer.
          The camera device then uses the most significant X bits
          that correspond to how many bits are in its Bayer raw sensor
          output.

          For example, a sensor with RAW10 Bayer output would use the
          10 most significant bits from each color channel.
          </details>
          <hal_details>
          </hal_details>
        </entry>
        <entry name="testPatternMode" type="int32" visibility="public" optional="true"
          enum="true">
          <enum>
            <value>OFF
              <notes>Default. No test pattern mode is used, and the camera
              device returns captures from the image sensor.</notes>
            </value>
            <value>SOLID_COLOR
              <notes>
              Each pixel in `[R, G_even, G_odd, B]` is replaced by its
              respective color channel provided in
              android.sensor.testPatternData.

              For example:

                  android.testPatternData = [0, 0xFFFFFFFF, 0xFFFFFFFF, 0]

              All green pixels are 100% green. All red/blue pixels are black.

                  android.testPatternData = [0xFFFFFFFF, 0, 0xFFFFFFFF, 0]

              All red pixels are 100% red. Only the odd green pixels
              are 100% green. All blue pixels are 100% black.
              </notes>
            </value>
            <value>COLOR_BARS
              <notes>
              All pixel data is replaced with an 8-bar color pattern.

              The vertical bars (left-to-right) are as follows:

              * 100% white
              * yellow
              * cyan
              * green
              * magenta
              * red
              * blue
              * black

              In general the image would look like the following:

                 W Y C G M R B K
                 W Y C G M R B K
                 W Y C G M R B K
                 W Y C G M R B K
                 W Y C G M R B K
                 . . . . . . . .
                 . . . . . . . .
                 . . . . . . . .

                 (B = Blue, K = Black)

             Each bar should take up 1/8 of the sensor pixel array width.
             When this is not possible, the bar size should be rounded
             down to the nearest integer and the pattern can repeat
             on the right side.

             Each bar's height must always take up the full sensor
             pixel array height.

             Each pixel in this test pattern must be set to either
             0% intensity or 100% intensity.
             </notes>
            </value>
            <value>COLOR_BARS_FADE_TO_GRAY
              <notes>
              The test pattern is similar to COLOR_BARS, except that
              each bar should start at its specified color at the top,
              and fade to gray at the bottom.

              Furthermore each bar is further subdivided into a left and
              right half. The left half should have a smooth gradient,
              and the right half should have a quantized gradient.

              In particular, the right half's should consist of blocks of the
              same color for 1/16th active sensor pixel array width.

              The least significant bits in the quantized gradient should
              be copied from the most significant bits of the smooth gradient.

              The height of each bar should always be a multiple of 128.
              When this is not the case, the pattern should repeat at the bottom
              of the image.
              </notes>
            </value>
            <value>PN9
              <notes>
              All pixel data is replaced by a pseudo-random sequence
              generated from a PN9 512-bit sequence (typically implemented
              in hardware with a linear feedback shift register).

              The generator should be reset at the beginning of each frame,
              and thus each subsequent raw frame with this test pattern should
              be exactly the same as the last.
              </notes>
            </value>
            <value id="256">CUSTOM1
              <notes>The first custom test pattern. All custom patterns that are
              available only on this camera device are at least this numeric
              value.

              All of the custom test patterns will be static
              (that is the raw image must not vary from frame to frame).
              </notes>
            </value>
          </enum>
          <description>When enabled, the sensor sends a test pattern instead of
          doing a real exposure from the camera.
          </description>
          <range>Optional. Defaults to OFF. Value must be one of
          android.sensor.availableTestPatternModes</range>
          <details>
          When a test pattern is enabled, all manual sensor controls specified
          by android.sensor.* should be ignored. All other controls should
          work as normal.

          For example, if manual flash is enabled, flash firing should still
          occur (and that the test pattern remain unmodified, since the flash
          would not actually affect it).
          </details>
          <hal_details>
          All test patterns are specified in the Bayer domain.

          The HAL may choose to substitute test patterns from the sensor
          with test patterns from on-device memory. In that case, it should be
          indistinguishable to the ISP whether the data came from the
          sensor interconnect bus (such as CSI2) or memory.
          </hal_details>
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.sensor.testPatternData" kind="controls">
        </clone>
        <clone entry="android.sensor.testPatternMode" kind="controls">
        </clone>
      </dynamic>
      <static>
        <entry name="availableTestPatternModes" type="int32" visibility="public" optional="true"
          type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>Optional. Defaults to [OFF]. Lists the supported test
            pattern modes for android.sensor.testPatternMode.
          </description>
          <range>Must include OFF. All custom modes must be >= CUSTOM1</range>
        </entry>

      </static>
    </section>
    <section name="shading">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>No lens shading correction is applied</notes></value>
            <value>FAST
            <notes>Must not slow down frame rate relative to sensor raw output</notes></value>
            <value>HIGH_QUALITY
            <notes>Frame rate may be reduced by high quality</notes></value>
          </enum>
          <description>Quality of lens shading correction applied
          to the image data.</description>
          <details>
          When set to OFF mode, no lens shading correction will be applied by the
          camera device, and an identity lens shading map data will be provided
          if `android.statistics.lensShadingMapMode == ON`. For example, for lens
          shading map with size specified as `android.lens.info.shadingMapSize = [ 4, 3 ]`,
          the output android.statistics.lensShadingMap for this case will be an identity map
          shown below:

              [ 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
                  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
                1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
                  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,
                1.0, 1.0, 1.0, 1.0,   1.0, 1.0, 1.0, 1.0,
                  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0 ]

          When set to other modes, lens shading correction will be applied by the
          camera device. Applications can request lens shading map data by setting
          android.statistics.lensShadingMapMode to ON, and then the camera device will provide
          lens shading map data in android.statistics.lensShadingMap, with size specified
          by android.lens.info.shadingMapSize.
          </details>
        </entry>
        <entry name="strength" type="byte">
          <description>Control the amount of shading correction
          applied to the images</description>
          <units>unitless: 1-10; 10 is full shading
          compensation</units>
          <tag id="ADV" />
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.shading.mode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="statistics">
      <controls>
        <entry name="faceDetectMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF</value>
            <value>SIMPLE
            <notes>Optional Return rectangle and confidence
            only</notes></value>
            <value>FULL
            <notes>Optional Return all face
            metadata</notes></value>
          </enum>
          <description>State of the face detector
          unit</description>
          <range>
          android.statistics.info.availableFaceDetectModes</range>
          <details>Whether face detection is enabled, and whether it
          should output just the basic fields or the full set of
          fields. Value must be one of the
          android.statistics.info.availableFaceDetectModes.</details>
          <tag id="BC" />
        </entry>
        <entry name="histogramMode" type="byte" enum="true" typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>Operating mode for histogram
          generation</description>
          <tag id="V1" />
        </entry>
        <entry name="sharpnessMapMode" type="byte" enum="true" typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>Operating mode for sharpness map
          generation</description>
          <tag id="V1" />
        </entry>
        <entry name="hotPixelMapMode" type="byte" visibility="public" enum="true"
        typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>
          Operating mode for hotpixel map generation.
          </description>
          <details>
          If set to ON, a hotpixel map is returned in android.statistics.hotPixelMap.
          If set to OFF, no hotpixel map should be returned.

          This must be set to a valid mode from android.statistics.info.availableHotPixelMapModes.
          </details>
          <tag id="V1" />
          <tag id="DNG" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="availableFaceDetectModes" type="byte"
                 visibility="public"
                 type_notes="List of enums from android.statistics.faceDetectMode"
                 container="array">
            <array>
              <size>n</size>
            </array>
            <description>Which face detection modes are available,
            if any</description>
            <units>List of enum:
            OFF
            SIMPLE
            FULL</units>
            <details>OFF means face detection is disabled, it must
            be included in the list.

            SIMPLE means the device supports the
            android.statistics.faceRectangles and
            android.statistics.faceScores outputs.

            FULL means the device additionally supports the
            android.statistics.faceIds and
            android.statistics.faceLandmarks outputs.
            </details>
          </entry>
          <entry name="histogramBucketCount" type="int32">
            <description>Number of histogram buckets
            supported</description>
            <range>&amp;gt;= 64</range>
          </entry>
          <entry name="maxFaceCount" type="int32" visibility="public" >
            <description>Maximum number of simultaneously detectable
            faces</description>
            <range>&amp;gt;= 4 if android.statistics.info.availableFaceDetectModes lists
            modes besides OFF, otherwise 0</range>
          </entry>
          <entry name="maxHistogramCount" type="int32">
            <description>Maximum value possible for a histogram
            bucket</description>
          </entry>
          <entry name="maxSharpnessMapValue" type="int32">
            <description>Maximum value possible for a sharpness map
            region.</description>
          </entry>
          <entry name="sharpnessMapSize" type="int32"
          type_notes="width x height" container="array" typedef="size">
            <array>
              <size>2</size>
            </array>
            <description>Dimensions of the sharpness
            map</description>
            <range>Must be at least 32 x 32</range>
          </entry>
          <entry name="availableHotPixelMapModes" type="byte" visibility="public"
          type_notes="list of enums" container="array" typedef="boolean">
            <array>
              <size>n</size>
            </array>
            <description>
            The set of hot pixel map output modes supported by this camera device.
            </description>
            <details>
            This tag lists valid output modes for android.statistics.hotPixelMapMode.

            If no hotpixel map is available for this camera device, this will contain
            only OFF.  If the hotpixel map is available, this should include both
            the ON and OFF options.
            </details>
            <tag id="V1" />
            <tag id="DNG" />
          </entry>
        </namespace>
      </static>
      <dynamic>
        <clone entry="android.statistics.faceDetectMode"
        kind="controls"></clone>
        <entry name="faceIds" type="int32" visibility="hidden" container="array">
          <array>
            <size>n</size>
          </array>
          <description>List of unique IDs for detected
          faces</description>
          <details>Only available if faceDetectMode == FULL</details>
          <tag id="BC" />
        </entry>
        <entry name="faceLandmarks" type="int32" visibility="hidden"
        type_notes="(leftEyeX, leftEyeY, rightEyeX, rightEyeY, mouthX, mouthY)"
        container="array">
          <array>
            <size>n</size>
            <size>6</size>
          </array>
          <description>List of landmarks for detected
          faces</description>
          <details>Only available if faceDetectMode == FULL</details>
          <tag id="BC" />
        </entry>
        <entry name="faceRectangles" type="int32" visibility="hidden"
        type_notes="(xmin, ymin, xmax, ymax). (0,0) is top-left of active pixel area"
        container="array" typedef="rectangle">
          <array>
            <size>n</size>
            <size>4</size>
          </array>
          <description>List of the bounding rectangles for detected
          faces</description>
          <details>Only available if faceDetectMode != OFF</details>
          <tag id="BC" />
        </entry>
        <entry name="faceScores" type="byte" visibility="hidden" container="array">
          <array>
            <size>n</size>
          </array>
          <description>List of the face confidence scores for
          detected faces</description>
          <range>1-100</range>
          <details>Only available if faceDetectMode != OFF. The value should be
          meaningful (for example, setting 100 at all times is illegal).</details>
          <tag id="BC" />
        </entry>
        <entry name="histogram" type="int32"
        type_notes="count of pixels for each color channel that fall into each histogram bucket, scaled to be between 0 and maxHistogramCount"
        container="array">
          <array>
            <size>n</size>
            <size>3</size>
          </array>
          <description>A 3-channel histogram based on the raw
          sensor data</description>
          <details>The k'th bucket (0-based) covers the input range
          (with w = android.sensor.info.whiteLevel) of [ k * w/N,
          (k + 1) * w / N ). If only a monochrome sharpness map is
          supported, all channels should have the same data</details>
          <tag id="V1" />
        </entry>
        <clone entry="android.statistics.histogramMode"
        kind="controls"></clone>
        <entry name="sharpnessMap" type="int32"
        type_notes="estimated sharpness for each region of the input image. Normalized to be between 0 and maxSharpnessMapValue. Higher values mean sharper (better focused)"
        container="array">
          <array>
            <size>n</size>
            <size>m</size>
            <size>3</size>
          </array>
          <description>A 3-channel sharpness map, based on the raw
          sensor data</description>
          <details>If only a monochrome sharpness map is supported,
          all channels should have the same data</details>
          <tag id="V1" />
        </entry>
        <clone entry="android.statistics.sharpnessMapMode"
        kind="controls"></clone>
        <entry name="lensShadingMap" type="float" visibility="public"
               type_notes="2D array of float gain factors per channel to correct lens shading"
               container="array">
          <array>
            <size>4</size>
            <size>n</size>
            <size>m</size>
          </array>
          <description>The shading map is a low-resolution floating-point map
          that lists the coefficients used to correct for vignetting, for each
          Bayer color channel.</description>
          <range>Each gain factor is &amp;gt;= 1</range>
          <details>The least shaded section of the image should have a gain factor
          of 1; all other sections should have gains above 1.

          When android.colorCorrection.mode = TRANSFORM_MATRIX, the map
          must take into account the colorCorrection settings.

          The shading map is for the entire active pixel array, and is not
          affected by the crop region specified in the request. Each shading map
          entry is the value of the shading compensation map over a specific
          pixel on the sensor.  Specifically, with a (N x M) resolution shading
          map, and an active pixel array size (W x H), shading map entry
          (x,y)  (0 ... N-1, 0 ... M-1) is the value of the shading map at
          pixel ( ((W-1)/(N-1)) * x, ((H-1)/(M-1)) * y) for the four color channels.
          The map is assumed to be bilinearly interpolated between the sample points.

          The channel order is [R, Geven, Godd, B], where Geven is the green
          channel for the even rows of a Bayer pattern, and Godd is the odd rows.
          The shading map is stored in a fully interleaved format, and its size
          is provided in the camera static metadata by android.lens.info.shadingMapSize.

          The shading map should have on the order of 30-40 rows and columns,
          and must be smaller than 64x64.

          As an example, given a very small map defined as:

              android.lens.info.shadingMapSize = [ 4, 3 ]
              android.statistics.lensShadingMap =
              [ 1.3, 1.2, 1.15, 1.2,  1.2, 1.2, 1.15, 1.2,
                  1.1, 1.2, 1.2, 1.2,  1.3, 1.2, 1.3, 1.3,
                1.2, 1.2, 1.25, 1.1,  1.1, 1.1, 1.1, 1.0,
                  1.0, 1.0, 1.0, 1.0,  1.2, 1.3, 1.25, 1.2,
                1.3, 1.2, 1.2, 1.3,   1.2, 1.15, 1.1, 1.2,
                  1.2, 1.1, 1.0, 1.2,  1.3, 1.15, 1.2, 1.3 ]

          The low-resolution scaling map images for each channel are
          (displayed using nearest-neighbor interpolation):

          ![Red lens shading map](android.statistics.lensShadingMap/red_shading.png)
          ![Green (even rows) lens shading map](android.statistics.lensShadingMap/green_e_shading.png)
          ![Green (odd rows) lens shading map](android.statistics.lensShadingMap/green_o_shading.png)
          ![Blue lens shading map](android.statistics.lensShadingMap/blue_shading.png)

          As a visualization only, inverting the full-color map to recover an
          image of a gray wall (using bicubic interpolation for visual quality) as captured by the sensor gives:

          ![Image of a uniform white wall (inverse shading map)](android.statistics.lensShadingMap/inv_shading.png)
          </details>
        </entry>
        <entry name="predictedColorGains" type="float"
               visibility="hidden"
               optional="true"
               type_notes="A 1D array of floats for 4 color channel gains"
               container="array">
          <array>
            <size>4</size>
          </array>
          <description>The best-fit color channel gains calculated
          by the camera device's statistics units for the current output frame.
          </description>
          <range>**Deprecated**. Do not use.</range>
          <details>
          This may be different than the gains used for this frame,
          since statistics processing on data from a new frame
          typically completes after the transform has already been
          applied to that frame.

          The 4 channel gains are defined in Bayer domain,
          see android.colorCorrection.gains for details.

          This value should always be calculated by the AWB block,
          regardless of the android.control.* current values.
          </details>
        </entry>
        <entry name="predictedColorTransform" type="rational"
               visibility="hidden"
               optional="true"
               type_notes="3x3 rational matrix in row-major order"
               container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>The best-fit color transform matrix estimate
          calculated by the camera device's statistics units for the current
          output frame.</description>
          <range>**Deprecated**. Do not use.</range>
          <details>The camera device will provide the estimate from its
          statistics unit on the white balance transforms to use
          for the next frame. These are the values the camera device believes
          are the best fit for the current output frame. This may
          be different than the transform used for this frame, since
          statistics processing on data from a new frame typically
          completes after the transform has already been applied to
          that frame.

          These estimates must be provided for all frames, even if
          capture settings and color transforms are set by the application.

          This value should always be calculated by the AWB block,
          regardless of the android.control.* current values.
          </details>
        </entry>
        <entry name="sceneFlicker" type="byte" visibility="public" enum="true">
          <enum>
            <value>NONE</value>
            <value>50HZ</value>
            <value>60HZ</value>
          </enum>
          <description>The camera device estimated scene illumination lighting
          frequency.</description>
          <details>
          Many light sources, such as most fluorescent lights, flicker at a rate
          that depends on the local utility power standards. This flicker must be
          accounted for by auto-exposure routines to avoid artifacts in captured images.
          The camera device uses this entry to tell the application what the scene
          illuminant frequency is.

          When manual exposure control is enabled
          (`android.control.aeMode == OFF` or `android.control.mode == OFF`),
          the android.control.aeAntibandingMode doesn't do the antibanding, and the
          application can ensure it selects exposure times that do not cause banding
          issues by looking into this metadata field. See android.control.aeAntibandingMode
          for more details.

          Report NONE if there doesn't appear to be flickering illumination.
          </details>
        </entry>
        <clone entry="android.statistics.hotPixelMapMode" kind="controls">
        </clone>
        <entry name="hotPixelMap" type="int32" visibility="public"
        type_notes="list of coordinates based on android.sensor.pixelArraySize"
        container="array">
          <array>
            <size>2</size>
            <size>n</size>
          </array>
          <description>
          List of `(x, y)` coordinates of hot/defective pixels on the sensor.
          </description>
          <range>
          n &lt;= number of pixels on the sensor.
          The `(x, y)` coordinates must be bounded by
          android.sensor.info.pixelArraySize.
          </range>
          <details>
          A coordinate `(x, y)` must lie between `(0, 0)`, and
          `(width - 1, height - 1)` (inclusive), which are the top-left and
          bottom-right of the pixel array, respectively. The width and
          height dimensions are given in android.sensor.info.pixelArraySize.
          This may include hot pixels that lie outside of the active array
          bounds given by android.sensor.info.activeArraySize.
          </details>
          <hal_details>
          A hotpixel map contains the coordinates of pixels on the camera
          sensor that do report valid values (usually due to defects in
          the camera sensor). This includes pixels that are stuck at certain
          values, or have a response that does not accuractly encode the
          incoming light from the scene.

          To avoid performance issues, there should be significantly fewer hot
          pixels than actual pixels on the camera sensor.
          </hal_details>
          <tag id="V1" />
          <tag id="DNG" />
        </entry>
      </dynamic>
      <controls>
        <entry name="lensShadingMapMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>Whether the camera device will output the lens
          shading map in output result metadata.</description>
          <details>When set to ON,
          android.statistics.lensShadingMap must be provided in
          the output result metadata.</details>
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.statistics.lensShadingMapMode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="tonemap">
      <controls>
        <entry name="curveBlue" type="float" visibility="public"
        type_notes="1D array of float pairs (P_IN, P_OUT). The maximum number of pairs is specified by android.tonemap.maxCurvePoints."
        container="array">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>Tonemapping / contrast / gamma curve for the blue
          channel, to use when android.tonemap.mode is
          CONTRAST_CURVE.</description>
          <units>same as android.tonemap.curveRed</units>
          <range>same as android.tonemap.curveRed</range>
          <details>See android.tonemap.curveRed for more details.</details>
        </entry>
        <entry name="curveGreen" type="float" visibility="public"
        type_notes="1D array of float pairs (P_IN, P_OUT). The maximum number of pairs is specified by android.tonemap.maxCurvePoints."
        container="array">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>Tonemapping / contrast / gamma curve for the green
          channel, to use when android.tonemap.mode is
          CONTRAST_CURVE.</description>
          <units>same as android.tonemap.curveRed</units>
          <range>same as android.tonemap.curveRed</range>
          <details>See android.tonemap.curveRed for more details.</details>
        </entry>
        <entry name="curveRed" type="float" visibility="public"
        type_notes="1D array of float pairs (P_IN, P_OUT). The maximum number of pairs is specified by android.tonemap.maxCurvePoints."
        container="array">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>Tonemapping / contrast / gamma curve for the red
          channel, to use when android.tonemap.mode is
          CONTRAST_CURVE.</description>
          <range>0-1 on both input and output coordinates, normalized
          as a floating-point value such that 0 == black and 1 == white.
          </range>
          <details>
          Each channel's curve is defined by an array of control points:

              android.tonemap.curveRed =
                [ P0in, P0out, P1in, P1out, P2in, P2out, P3in, P3out, ..., PNin, PNout ]
              2 &lt;= N &lt;= android.tonemap.maxCurvePoints

          These are sorted in order of increasing `Pin`; it is always
          guaranteed that input values 0.0 and 1.0 are included in the list to
          define a complete mapping. For input values between control points,
          the camera device must linearly interpolate between the control
          points.

          Each curve can have an independent number of points, and the number
          of points can be less than max (that is, the request doesn't have to
          always provide a curve with number of points equivalent to
          android.tonemap.maxCurvePoints).

          A few examples, and their corresponding graphical mappings; these
          only specify the red channel and the precision is limited to 4
          digits, for conciseness.

          Linear mapping:

              android.tonemap.curveRed = [ 0, 0, 1.0, 1.0 ]

          ![Linear mapping curve](android.tonemap.curveRed/linear_tonemap.png)

          Invert mapping:

              android.tonemap.curveRed = [ 0, 1.0, 1.0, 0 ]

          ![Inverting mapping curve](android.tonemap.curveRed/inverse_tonemap.png)

          Gamma 1/2.2 mapping, with 16 control points:

              android.tonemap.curveRed = [
                0.0000, 0.0000, 0.0667, 0.2920, 0.1333, 0.4002, 0.2000, 0.4812,
                0.2667, 0.5484, 0.3333, 0.6069, 0.4000, 0.6594, 0.4667, 0.7072,
                0.5333, 0.7515, 0.6000, 0.7928, 0.6667, 0.8317, 0.7333, 0.8685,
                0.8000, 0.9035, 0.8667, 0.9370, 0.9333, 0.9691, 1.0000, 1.0000 ]

          ![Gamma = 1/2.2 tonemapping curve](android.tonemap.curveRed/gamma_tonemap.png)

          Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:

              android.tonemap.curveRed = [
                0.0000, 0.0000, 0.0667, 0.2864, 0.1333, 0.4007, 0.2000, 0.4845,
                0.2667, 0.5532, 0.3333, 0.6125, 0.4000, 0.6652, 0.4667, 0.7130,
                0.5333, 0.7569, 0.6000, 0.7977, 0.6667, 0.8360, 0.7333, 0.8721,
                0.8000, 0.9063, 0.8667, 0.9389, 0.9333, 0.9701, 1.0000, 1.0000 ]

          ![sRGB tonemapping curve](android.tonemap.curveRed/srgb_tonemap.png)
        </details>
        <hal_details>
          For good quality of mapping, at least 128 control points are
          preferred.

          A typical use case of this would be a gamma-1/2.2 curve, with as many
          control points used as are available.
        </hal_details>
        </entry>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>CONTRAST_CURVE
              <notes>Use the tone mapping curve specified in
              the android.tonemap.curve* entries.

              All color enhancement and tonemapping must be disabled, except
              for applying the tonemapping curve specified by
              android.tonemap.curveRed, android.tonemap.curveBlue, or
              android.tonemap.curveGreen.

              Must not slow down frame rate relative to raw
              sensor output.
              </notes>
            </value>
            <value>FAST
              <notes>
              Advanced gamma mapping and color enhancement may be applied.

              Should not slow down frame rate relative to raw sensor output.
              </notes>
            </value>
            <value>HIGH_QUALITY
              <notes>
              Advanced gamma mapping and color enhancement may be applied.

              May slow down frame rate relative to raw sensor output.
              </notes>
            </value>
          </enum>
          <description>High-level global contrast/gamma/tonemapping control.
          </description>
          <details>
          When switching to an application-defined contrast curve by setting
          android.tonemap.mode to CONTRAST_CURVE, the curve is defined
          per-channel with a set of `(in, out)` points that specify the
          mapping from input high-bit-depth pixel value to the output
          low-bit-depth value.  Since the actual pixel ranges of both input
          and output may change depending on the camera pipeline, the values
          are specified by normalized floating-point numbers.

          More-complex color mapping operations such as 3D color look-up
          tables, selective chroma enhancement, or other non-linear color
          transforms will be disabled when android.tonemap.mode is
          CONTRAST_CURVE.

          This must be set to a valid mode in
          android.tonemap.availableToneMapModes.

          When using either FAST or HIGH_QUALITY, the camera device will
          emit its own tonemap curve in android.tonemap.curveRed,
          android.tonemap.curveGreen, and android.tonemap.curveBlue.
          These values are always available, and as close as possible to the
          actually used nonlinear/nonglobal transforms.

          If a request is sent with TRANSFORM_MATRIX with the camera device's
          provided curve in FAST or HIGH_QUALITY, the image's tonemap will be
          roughly the same.</details>
        </entry>
      </controls>
      <static>
        <entry name="maxCurvePoints" type="int32" visibility="public" >
          <description>Maximum number of supported points in the
            tonemap curve that can be used for android.tonemap.curveRed, or
            android.tonemap.curveGreen, or android.tonemap.curveBlue.
          </description>
          <range>&amp;gt;= 64</range>
          <details>
          If the actual number of points provided by the application (in
          android.tonemap.curve*)  is less than max, the camera device will
          resample the curve to its internal representation, using linear
          interpolation.

          The output curves in the result metadata may have a different number
          of points than the input curves, and will represent the actual
          hardware curves used as closely as possible when linearly interpolated.
          </details>
          <hal_details>
          This value must be at least 64. This should be at least 128.
          </hal_details>
        </entry>
        <entry name="availableToneMapModes" type="byte" visibility="public"
        type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>
          The set of tonemapping modes supported by this camera device.
          </description>
          <details>
          This tag lists the valid modes for android.tonemap.mode.

          Full-capability camera devices must always support CONTRAST_CURVE and
          FAST.
          </details>
        </entry>
      </static>
      <dynamic>
        <clone entry="android.tonemap.curveBlue" kind="controls">
        </clone>
        <clone entry="android.tonemap.curveGreen" kind="controls">
        </clone>
        <clone entry="android.tonemap.curveRed" kind="controls">
        </clone>
        <clone entry="android.tonemap.mode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="led">
      <controls>
        <entry name="transmit" type="byte" visibility="hidden" enum="true"
               typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>This LED is nominally used to indicate to the user
          that the camera is powered on and may be streaming images back to the
          Application Processor. In certain rare circumstances, the OS may
          disable this when video is processed locally and not transmitted to
          any untrusted applications.

          In particular, the LED *must* always be on when the data could be
          transmitted off the device. The LED *should* always be on whenever
          data is stored locally on the device.

          The LED *may* be off if a trusted application is using the data that
          doesn't violate the above rules.
          </description>
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.led.transmit" kind="controls"></clone>
      </dynamic>
      <static>
        <entry name="availableLeds" type="byte" visibility="hidden" enum="true"
               container="array">
          <array>
            <size>n</size>
          </array>
          <enum>
            <value>TRANSMIT
              <notes>android.led.transmit control is used</notes>
            </value>
          </enum>
          <description>A list of camera LEDs that are available on this system.
          </description>
        </entry>
      </static>
    </section>
    <section name="info">
      <static>
        <entry name="supportedHardwareLevel" type="byte" visibility="public"
               enum="true" >
          <enum>
            <value>LIMITED</value>
            <value>FULL</value>
          </enum>
          <description>
          Generally classifies the overall set of the camera device functionality.
          </description>
          <range>Optional. Default value is LIMITED.</range>
          <details>
          Camera devices will come in two flavors: LIMITED and FULL.

          A FULL device has the most support possible and will enable the
          widest range of use cases such as:

          * 30 FPS at maximum resolution (== sensor resolution)
          * Per frame control
          * Manual sensor control
          * Zero Shutter Lag (ZSL)

          A LIMITED device may have some or none of the above characteristics.
          To find out more refer to android.request.availableCapabilities.
          </details>
          <hal_details>
          The camera 3 HAL device can implement one of two possible
          operational modes; limited and full. Full support is
          expected from new higher-end devices. Limited mode has
          hardware requirements roughly in line with those for a
          camera HAL device v1 implementation, and is expected from
          older or inexpensive devices. Full is a strict superset of
          limited, and they share the same essential operational flow.

          For full details refer to "S3. Operational Modes" in camera3.h
          </hal_details>
        </entry>
      </static>
    </section>
    <section name="blackLevel">
      <controls>
        <entry name="lock" type="byte" visibility="public" enum="true"
               typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description> Whether black-level compensation is locked
          to its current values, or is free to vary.</description>
          <details>When set to ON, the values used for black-level
          compensation will not change until the lock is set to
          OFF.

          Since changes to certain capture parameters (such as
          exposure time) may require resetting of black level
          compensation, the camera device must report whether setting
          the black level lock was successful in the output result
          metadata.

          For example, if a sequence of requests is as follows:

          * Request 1: Exposure = 10ms, Black level lock = OFF
          * Request 2: Exposure = 10ms, Black level lock = ON
          * Request 3: Exposure = 10ms, Black level lock = ON
          * Request 4: Exposure = 20ms, Black level lock = ON
          * Request 5: Exposure = 20ms, Black level lock = ON
          * Request 6: Exposure = 20ms, Black level lock = ON

          And the exposure change in Request 4 requires the camera
          device to reset the black level offsets, then the output
          result metadata is expected to be:

          * Result 1: Exposure = 10ms, Black level lock = OFF
          * Result 2: Exposure = 10ms, Black level lock = ON
          * Result 3: Exposure = 10ms, Black level lock = ON
          * Result 4: Exposure = 20ms, Black level lock = OFF
          * Result 5: Exposure = 20ms, Black level lock = ON
          * Result 6: Exposure = 20ms, Black level lock = ON

          This indicates to the application that on frame 4, black
          levels were reset due to exposure value changes, and pixel
          values may not be consistent across captures.

          The camera device will maintain the lock to the extent
          possible, only overriding the lock to OFF when changes to
          other request parameters require a black level recalculation
          or reset.
          </details>
          <hal_details>
          If for some reason black level locking is no longer possible
          (for example, the analog gain has changed, which forces
          black level offsets to be recalculated), then the HAL must
          override this request (and it must report 'OFF' when this
          does happen) until the next capture for which locking is
          possible again.</hal_details>
          <tag id="HAL2" />
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.blackLevel.lock"
          kind="controls">
          <details>
            Whether the black level offset was locked for this frame.  Should be
            ON if android.blackLevel.lock was ON in the capture request, unless
            a change in other capture settings forced the camera device to
            perform a black level reset.
          </details>
        </clone>
      </dynamic>
    </section>
    <section name="sync">
      <dynamic>
        <entry name="frameNumber" type="int64" visibility="hidden" enum="true">
          <enum>
            <value id="-1">CONVERGING
              <notes>
              The current result is not yet fully synchronized to any request.
              Synchronization is in progress, and reading metadata from this
              result may include a mix of data that have taken effect since the
              last synchronization time.

              In some future result, within android.sync.maxLatency frames,
              this value will update to the actual frame number frame number
              the result is guaranteed to be synchronized to (as long as the
              request settings remain constant).
            </notes>
            </value>
            <value id="-2">UNKNOWN
              <notes>
              The current result's synchronization status is unknown. The
              result may have already converged, or it may be in progress.
              Reading from this result may include some mix of settings from
              past requests.

              After a settings change, the new settings will eventually all
              take effect for the output buffers and results. However, this
              value will not change when that happens. Altering settings
              rapidly may provide outcomes using mixes of settings from recent
              requests.

              This value is intended primarily for backwards compatibility with
              the older camera implementations (for android.hardware.Camera).
            </notes>
            </value>
          </enum>
          <description>The frame number corresponding to the last request
          with which the output result (metadata + buffers) has been fully
          synchronized.</description>
          <range>Either a non-negative value corresponding to a
          `frame_number`, or one of the two enums (CONVERGING / UNKNOWN).
          </range>
          <details>
          When a request is submitted to the camera device, there is usually a
          delay of several frames before the controls get applied. A camera
          device may either choose to account for this delay by implementing a
          pipeline and carefully submit well-timed atomic control updates, or
          it may start streaming control changes that span over several frame
          boundaries.

          In the latter case, whenever a request's settings change relative to
          the previous submitted request, the full set of changes may take
          multiple frame durations to fully take effect. Some settings may
          take effect sooner (in less frame durations) than others.

          While a set of control changes are being propagated, this value
          will be CONVERGING.

          Once it is fully known that a set of control changes have been
          finished propagating, and the resulting updated control settings
          have been read back by the camera device, this value will be set
          to a non-negative frame number (corresponding to the request to
          which the results have synchronized to).

          Older camera device implementations may not have a way to detect
          when all camera controls have been applied, and will always set this
          value to UNKNOWN.

          FULL capability devices will always have this value set to the
          frame number of the request corresponding to this result.

          _Further details_:

          * Whenever a request differs from the last request, any future
          results not yet returned may have this value set to CONVERGING (this
          could include any in-progress captures not yet returned by the camera
          device, for more details see pipeline considerations below).
          * Submitting a series of multiple requests that differ from the
          previous request (e.g. r1, r2, r3 s.t. r1 != r2 != r3)
          moves the new synchronization frame to the last non-repeating
          request (using the smallest frame number from the contiguous list of
          repeating requests).
          * Submitting the same request repeatedly will not change this value
          to CONVERGING, if it was already a non-negative value.
          * When this value changes to non-negative, that means that all of the
          metadata controls from the request have been applied, all of the
          metadata controls from the camera device have been read to the
          updated values (into the result), and all of the graphics buffers
          corresponding to this result are also synchronized to the request.

          _Pipeline considerations_:

          Submitting a request with updated controls relative to the previously
          submitted requests may also invalidate the synchronization state
          of all the results corresponding to currently in-flight requests.

          In other words, results for this current request and up to
          android.request.pipelineMaxDepth prior requests may have their
          android.sync.frameNumber change to CONVERGING.
          </details>
          <hal_details>
          Using UNKNOWN here is illegal unless android.sync.maxLatency
          is also UNKNOWN.

          FULL capability devices should simply set this value to the
          `frame_number` of the request this result corresponds to.
          </hal_details>
          <tag id="LIMITED" />
        </entry>
      </dynamic>
      <static>
        <entry name="maxLatency" type="int32" visibility="public" enum="true">
          <enum>
            <value id="0">PER_FRAME_CONTROL
              <notes>
              Every frame has the requests immediately applied.
              (and furthermore for all results,
              `android.sync.frameNumber == android.request.frameCount`)

              Changing controls over multiple requests one after another will
              produce results that have those controls applied atomically
              each frame.

              All FULL capability devices will have this as their maxLatency.
              </notes>
            </value>
            <value id="-1">UNKNOWN
              <notes>
              Each new frame has some subset (potentially the entire set)
              of the past requests applied to the camera settings.

              By submitting a series of identical requests, the camera device
              will eventually have the camera settings applied, but it is
              unknown when that exact point will be.
              </notes>
            </value>
          </enum>
          <description>
          The maximum number of frames that can occur after a request
          (different than the previous) has been submitted, and before the
          result's state becomes synchronized (by setting
          android.sync.frameNumber to a non-negative value).
          </description>
          <units>number of processed requests</units>
          <range>&amp;gt;= -1</range>
          <details>
          This defines the maximum distance (in number of metadata results),
          between android.sync.frameNumber and the equivalent
          android.request.frameCount.

          In other words this acts as an upper boundary for how many frames
          must occur before the camera device knows for a fact that the new
          submitted camera settings have been applied in outgoing frames.

          For example if the distance was 2,

              initial request = X (repeating)
              request1 = X
              request2 = Y
              request3 = Y
              request4 = Y

              where requestN has frameNumber N, and the first of the repeating
              initial request's has frameNumber F (and F &lt; 1).

              initial result = X' + { android.sync.frameNumber == F }
              result1 = X' + { android.sync.frameNumber == F }
              result2 = X' + { android.sync.frameNumber == CONVERGING }
              result3 = X' + { android.sync.frameNumber == CONVERGING }
              result4 = X' + { android.sync.frameNumber == 2 }

              where resultN has frameNumber N.

          Since `result4` has a `frameNumber == 4` and
          `android.sync.frameNumber == 2`, the distance is clearly
          `4 - 2 = 2`.
          </details>
          <hal_details>
          Use `frame_count` from camera3_request_t instead of
          android.request.frameCount.

          LIMITED devices are strongly encouraged to use a non-negative
          value. If UNKNOWN is used here then app developers do not have a way
          to know when sensor settings have been applied.
          </hal_details>
          <tag id="LIMITED" />
        </entry>
      </static>
    </section>
  </namespace>
</metadata>
